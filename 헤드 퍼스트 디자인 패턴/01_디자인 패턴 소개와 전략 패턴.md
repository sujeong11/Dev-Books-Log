## 상속 문제점

- SimpleUDuck이라는 오리 시뮬레이션 게임이 있다.
- 이 게임에는 헤엄도 치고 꽥꽥 소리도 내는 매우 다양한 오리가 존재한다.
- `Duck`이라는 `슈퍼클래스`를 만든 다음, 이 클래스를 `확장`해서 서로 다른 다른 종류를 만든다면?
    - 슈퍼클래스에 fly()라는 메서드를 추가하면 **모든 서브클래스는 이 메서드를 상속받는다.**
    - 만약, 몇몇 서브클래스만 날아야 한다면 날지 않아야 하는 서브클래스에는 아무것도 하지 않도록 오버라이드를 해줘야 한다. → `유지보수에 별로 안 좋다.`
        
        ```java
        fly() {
        	// 아무것도 하지 않도록 오버라이드
        }
        ```
        
- 이를 통해 알 수 있는 `상속의 단점`
    - **서브클래스에 코드가 중복된다.**
    - **실행 시에 특징을 바꾸기 힘들다.**
    - **모든 오리의 행동을 알기 어렵다.**
    - **코드를 변경했을 때 다른 오리들에게 원치 않은 영향을 끼칠 수 있다.**

<br>
<br>

## [문제 해결 시도] 인터페이스 사용

- fly()를 Duck 슈퍼클래스에서 뺀다. 그리고 fly() 메서드가 있는 Flyabble `인터페이스`를 만들어 날 수 있는 오리에게만 이 인터페이스를 구현하도록 한다.
- 이 방법은 `코드 중복이 발생`한다. **날아가는 동작을 조금 바꾸기 위해서는 Duck의 서브클래스의 fly() 코드를 모두 고쳐줘야 한다. →** `버그 발생 가능성 up`
- 즉, **코드 재사용을 하지 않으므로 관리에 커다란 문제가 생긴다.**

<br>
<br>

## [1] 첫 번째 디자인 원칙

💡 **애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.**

- 바뀌는 부분은 따로 뽑아서 `캡슐화`한다. 그러면 **나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다. →** `유연성 up`
    
    > 모든 디자인 패턴의 기반을 이루는 원칙
    > 

### [첫 번째 디자인 원칙 적용] 바뀌는 부분과 그렇지 않은 부분 분리하기

1. 슈퍼클래스 Duck으로부터 **바뀌는 부분을 뽑아낸다.**
    - `나는 행동`
    - `꽥꽥거리는 행동`
2. **각 행동을 나타낼 클래스 집합을 새로 만들어** 각각의 행동을 구현한 것을 전부 집어넣는다.
    - ex) 꽥꽥거리는 행동을 구현하는 클래스를 만들고, 빽빽거리는 행동을 구현하는 클래스 만들고, 아무 소리도 내지 않는 행동 등을 만든다.

<br>
<br>

## [2] 두 번째 디자인 원칙

💡 **구현보다는 인터페이스에 맞춰서 프로그래밍 한다.**

> 사실, “상위 형식에 맞춰서 프로그래밍한다”라는 말이다.
> 

- `인터페이스`: FlyBehavior
    
    ```java
    fly()
    ```
    
- `인터페이스 구현`
    - FlyWithWings
    
    ```java
    fly() {
    	// 나는 방법을 구현
    }
    ```
    
    - FlyNoWay
    
    ```java
    fly() {
    	// 아무것도 하지 않음. 날 수 없다.
    }
    ```
    
- **Duck 서브클래스는 인터페이스로 표현되는 행동을 사용**한다.
- 이제는 **Duck 클래스에서는 행동을 구체적으로 구현할 필요가 없다.**

### [주의] 반드시 인터페이스를 사용해야 하는 것은 아니다.

- 핵심 - **실제 실행 시에 쓰이는 객체가 코드에 고정되지 않도록 상위 형식에 맞춰 프로그래밍해서** `다형성`**을 활용해야 한다는 것**
- 객체를 변수에 대입할 때 **상위 형식을 구체적으로 구현한 형식이라면 어떤 객체를 넣을 수 있다.**
- 그러면 변수를 선언하는 클래스에서 **실제 객체의 형식을 몰라도 된다.**
- 예제
    - Animal라는 추상클래스/인터페이스를 구현한 Dog 클래스가 있을 때
    
    ```java
    Animal animal = new Dog();
    animal.makeSound(); // 단지, 해당 메서드가 올바른 반응만 할 수 있으면 된다.
    ```
    

### [두 번째 디자인 원칙 적용] 인터페이스 2개 사용

- 인터페이스: FlyBehavior
    - 구현한 행동 클래스: `FlyWithWings`(날 수 있음), `FlyNoWay`(날 수 없음)
- 인터페이스: QuackBehavior
    - 구현한 행동 클래스: `Quack`(꽥꽥거림), `Squeak`(빽빽거림), `MuteQuack`(소리 못냄)
- 이제 **코드 재사용이 가능**하다.
- 그리고 **기존의 행동 클래스를 수정하거나 날아다니는 행동을 사용하는 Duck 클래스를 전혀 건드리지 않고도 새로운 행동 추가 가능하다.**

<br>
<br>

## [3] 세 번째 디자인 원칙

💡 **상속보다는 구성을 활용한다.**

- “A에는 B가 있다.”
- **두 클래스를 합치는 것**을 `구성`을 이용한다라고 한다.

### [세 번째 디자인 원칙 적용] 오리 행동 통합하기

```java
public abstract class Duck {
	
	FlyBehavior flyBehavior;
	QuackBehavior quackBehavior;

	public Duck() { }

	public abstract void display();

	public void performFly() {
		flyBehavior.fly(); // 행동 클래스에 위임
	}

	public void performQuack() {
		quackBehavior.quack(); // 행동 클래스에 위임
	}

	public void swim() {
		...
	}
}
```

- 동적으로 행동 지정하기
- 오리의 행동을 바꾸고 싶다면 원하는 행동에 대한 `setter 메서드 호출`하면 된다.

```java
// Duck 클래스
public void setFlyBehavior(FlyBehavior fb) {
	flyBehavior = fb;
}

public void setQuackBehavior(QuackBehavior qb) {
	quackBehavior = qb;
}
```

```java
Duck model = new 구현클래스();
model.performFly();
model.setFlyBehavior();
model.performFly();
```

<br>
<br>

## 첫 번째 디자인 패턴: 전략 패턴

> SimpleUDuck을 바꾸는데 해당 패턴 사용
> 
- **알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해준다.**
- **전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.**

<br>
<br>

## 패턴과 전문 용어

- 패턴으로 소통하면 구구절절 말할 때보다 훨씬 효율적인 의사소통이 가능하다.
