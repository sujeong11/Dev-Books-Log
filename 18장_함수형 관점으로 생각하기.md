## 18.1 시스템 구현과 유지보수

유지 보수 중 코드 크래시 디버깅 문제로 가장 많은 겪게 된다. 코드 크래시는 예상하지 못한 변수 값 때문에 발생할 수 있다. 함수형 프로그래밍이 제공하는 `부작용 없음`과 `불변성`이라는 개념이 이 문제를 해결하는데 도움을 준다.

### 공유된 가변 데이터

변수가 예상하지 못한 값을 갖는 이유는 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다. 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워진다.

`부작용 없는 메서드`: 자신을 포함하는 클래스의 상태와 다른 객체의 상태를 바꾸지 않으며 **return 문을 통해서만 자신의 결과를 반환하는 메서드**

- 부작용의 예
    - 자료구조를 고치거나 필드에 값을 할당 (setter 메서드)
    - 예외 발생
    - 파일에 쓰기 등의 I/O 동작 수행

[ 해결 ] `불변 객체 사용` → 객체의 상태를 바꿀 수 없으므로 **스레드 안전성을 제공**

### 선언형 프로그래밍

`객체지향 프로그래밍`: ‘**어떻게**’에 집중하는 프로그래밍 형식

`선언형 프로그래밍`: ‘**무엇을**’에 집중하는 프로그래밍 형식


### 왜 함수형 프로그래밍인가?

(선언형 프로그래밍을 따르는 대표적인 방식 + 부작용이 없는 계산을 지향)

→ 더 쉽게 시스템을 구현하고 유지 보수하는데 도움을 준다.

ex) 람다 표현식, 스트림

<br>

## 18.2 함수형 프로그래밍이란 무엇인가?

`함수형`: 수학의 함수처럼 부작용이 없는 것을 의미

`순수 함수형 프로그래밍`: 함수 그리고 if-then-else 등의 수학적 표현만 사용

`함수형 프로그래밍`: **시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용** 

### 함수형 자바

> 실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다.
> 

예를 들어 자바의 I/O 모델 자체에는 부작용 메서드가 포함된다. 하지만 시스템의 컴포넌트가 순수한 함수형인 것처럼 동작하도록 코드를 구현할 수 있다. 자바에서는 순수 함수형이 아니라 함수형 프로그램을 구현할 것이다.

`함수나 메서드는 지역 변수만을 변경`해야 함수형이라 할 수 있다. 그리고 함수나 메서드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야 한다. 즉, `객체의 모든 필드가 final이어야 하고 모든 참조 필드는 불변 객체를 직접 참조`해야 한다. 이 외에도  함수형이라면 **`함수나 메서드가 어떤 예외도 일으키지 않아야 한다.`** return으로 결과를 반환할 수 없게 될 수 있기 때문이다.

### 참조 투명성

> 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환
>

비싸거나 오랜 시간이 걸리는 연산을 **기억화** 또는 **캐싱**을 통해 다시 계산하지 않고 저장하는 최적화하는 기능을 제공한다.

[ 문제 ] List를 반환하는 메서드를 두 번 호출한다고 가정하자. 두 번의 호출 결과로 같은 요소를 포함하지만 **서로 다른 메모리 공간에 생성된 리스트를 참조**할 것이다. 그러므로 해당 메서드는 참조적으로 **투명한 메서드가 아니라는 결론**이 나온다. 그러나 **리스트를 (불변의) 순수값으로 사용할 것이라면** 두 리스트가 **같은 객체라고 볼 수 있으므로 참조적으로 투명한 것으로 간주**할 수 있다. 

⇒ `함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주`한다. 

<br>

## 18.4 마치며

- 공유된 가변 자료구조를 줄이는 것은 장기적으로 프로그램을 유지 보수하고 디버깅하는데 도움이 된다.
- 함수형 프로그래밍은 부작용이 없는 메서드와 선언형 프로그래밍 방식을 지향한다.
- 함수형 메서드는 입력 인수와 출력 결과만을 갖는다.
- 같은 인수값으로 함수를 호출했을 때 항상 같은 값을 반환하면 참조 투명성을 갖는 함수다.
- while 루프 같은 반복문은 재귀로 대체할 수 있다.
- 자바에서 고전 방식의 재귀보다는 꼬리 재귀를 사용해야 추가적인 컴파일러 최적화를 기대할 수 있다.
