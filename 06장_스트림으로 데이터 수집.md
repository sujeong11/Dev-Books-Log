스트림은 데이터 집합을 멋지게 처리하는 `게으른 반복자`라고 설명할 수 있다. 중간 연산 reduce 처럼 collect 역시 **다양한 요소 누적 방식을 인수**로 받아서 **스트림을 최종 결과로 도출**하는 리듀싱 연산을 수행할 수 있다. **다양한 요소 누적 방식**은 **Collector 인터페이스에 정의**되어 있다.

> 컬레션, 컬렉터, collect를 헷갈리지 않도록 주의하자.

<br>

## 6.1 컬렉터란 무엇인가?

Collector 인터페이스 구현은 **스트림의 요소를 어떤 식으로 도출할지 지정**한다.

최대 장점: **collect 결과를 수집하는 과정**을 **간단하면서도 유연한 방식으로 정의할 수 있다는 점**

### 고급 리듀싱 기능을 수행하는 컬렉터

스트림에서 collect를 호출하면 스트림의 요소에 (컬렉터로 파라미터화된) 리듀싱 연산이 수행된다. collect에서는 리듀싱 연산을 이용해서 스트림의 각 요소를 방문하면서 컬렉터가 작업을 처리한다.

ex) 함수를 요소로 변환할 때: 컬렉터를 적용하며 최종 결과를 저장하는 자료구조에 값을 누적한다.

- Collectors 유틸리티 클래스는 자주 사용하는 컬렉터 인스턴스를 손쉽게 생성할 수 있는 정적 팩토리 메서드를 제공한다.

```java
transcationStream.collect(Collectors.toList()); // 정적 메서드의 예: toList()
```

### 미리 정의된 컬렉터

Collectors에서 제공하는 메서드의 기능은 크게 세 가지로 구분할 수 있다.

- 스트림 요소를 하나의 값을 리듀스하고 요약
- 요소 그룹화
- 요소 분할

<br>

## 6.2 리듀싱과 요약

컬렉터(Stream.collect 메서드의 인수)로 스트림의 항목을 컬렉션으로 재구성할 수 있다.

- 메뉴에서 요리 수를 계산하는 예제: `counting()`

```java
import static java.util.stream.Collectors.*;

// long howManyDishes = menu.stream().collect(Collectors.counting());
long howManyDishes = menu.stream().count();
```

### 스트림 값에서 최댓값과 최솟값 검색

`Collectors.maxBy` / `Collectors.minBy`: 두 컬렉터는 스트림의 요소를 **비교하는데 사용할 Comparator를 인수로 받는다.**

```java
Comaprator<Dish> dishCaloriesCompartor = Comparator.comparingInt(Dish::getCalories);
Optional<Dish> mostCaloriesDish = menu.stream().collect(maxBy(dishCaloriesCompartor));
```

### 요약 연산

`요약 연산`: 스트림에 있는 개게의 숫자 필드의 합계나 평균 등을 반환하는 연산. 이 연산에 리듀싱 기능이 자주 사용된다.

Collectors 클래스는 `summingInt`, `summingDouble`라는 특별한 요약 팩터리 메서드를 제공한다. 

`summingInt`: 객체를 int로 매핑하는 함수를 인수로 받는다. 인수로 전달된 함수는 객체를 int로 매핑한 컬렉터를 반환한다.

```java
int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));
```

이 외에도 `averagingInt`, `averagingLong`, `averagingDouble` 등으로 다양한 형식으로 이루어진 숫자 집합의 평균을 게산할 수 있다.

```java
IntSummaryStatistics menuStatistics =
     menu.stream().collect(averagingInt(Dish::getCalories));
```

만약, 두 개 이상의 연산을 한 번에 수행해야 한다면?

팩토리 메서드 `summarizingInt`, `summarizingLong`, `summarizingDouble`가 반환하는 컬렉터를 사용할 수 있다.

```java
// IntSummaryStatistics 클래스로 모든 정보가 수집된다.
IntSummaryStatistics menuStatistics =
     menu.stream().collect(summarizingInt(Dish::getCalories));
```

```java
// menuStatistics 객체를 출하면
IntSummaryStatistics{count=9, sum=4300, min=120, average=477.777778, max=800}
```

### 문자열 연결

`joining`: 스트림의 **각 객체에 toString 메서드를 호출**해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환. 내부적으로 **StringBuilder를 이용해서 문자열을 하나로 만든다.**

- 메뉴의 모든 요리명을 연결해보자.

```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining());
```

- 연결한 문자열 사이에 구분자를 넣어보자.

```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining(", "));
```

### 범용 리듀싱 요약 연산

지금까지 살펴본 모든 컬렉터는 reducing 팩터리 메서드로도 정의 가능하다. 즉, 범용 Collectors.reducing으로도 구현할 수 있다. (이전 예제들을 설명한 이유는 편의성 + 가독성 때문)

- 메뉴의 모든 칼로리 합계 계산

```java
int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i, j) -> i + j));
```

[ reducing은 `인수 세 개`를 받는다. ]

[1] 리듀싱 연산의 시작 값 or 스트림에 인수가 없을 때의 반환 값

[2] 함수

[3] 같은 종류의 두 항목을 하나의 값으로 더하는 BinaryOperator

- 가장 칼로리가 높은 요리를 찾는 예제

```java
Optional<Dish> mostCaloireDish = 
     menu.stream().collect(reducing(
          (d1, d2) -> d1.getCaloreis() > d2.getCalories() ? d1 : d2));
```

**한 개의 인수를 갖는 reducing 팩토리 메서드**는 세 개의 인수를 갖는 reducing 메서드에서 스트림의 첫 번째 요소를 시작 요소, 즉 첫 번째 인수로 받으며, 자신을 그대로 반환하는 `항등 함수`를 두 번째 인수로 받는 상황에 해당한다.

즉, 시작값이 없으므로 빈 스트림이 넘겨졌을 때 시작값이 설정되지 않는 상황이 벌어진다. 그래서 Optional 타입의 객체를 반환한다.
