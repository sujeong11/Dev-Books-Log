## 단일 서버

- 모든 컴포넌트가 단 한 대의 서버에서 실행되는 간단한 시스템부터 설계해보자.
- 웹, 앱, 데이터베이스, 캐시 등이 전부 `서버 한 대`에서 실행된다.

<br>
<br>
<br>

## 데이터 베이스

- ***사용자가 늘면***  `여러 대의 서버` 두어야 한다.
- 웹/모바일 트래픽 처리 서버와 데이터베이스 서버를 **분리**해 각각 확장해나갈 수 있다.

### 어떤 DB를 사용할 것인가?

- [1] 관계형 DB, [2] 비관계형 DB
- 대부분 1번을 더 많이 사용하지만, 아래와 같은 경우에서는 2번을 사용하기도 한다.
  - 아주 낮은 응답 시간을 요구
  - 비정형 데이터를 다룸
  - 데이터를 직렬화 or 역직렬화 할 수 있기만 하면 됨
  - 아주 많은 데이터를 저장해야 함

<br>
<br>
<br>

## 수직적 규모 확장 vs 수평적 규모 확장

### 수직적 규모 확장: scale-up

- 서버에 고사양 자원 (더 좋은 CPU, 더 많은 RAM, …)을 추가하는 것
- 서버로 유입되는 트래픽의 양이 적을 때 좋음
- 장점
    - 단순함
- 단점
    - 성능을 늘리는 것에 한계가 존재
    - 서버에 장애가 발생하면 치명적 (전체가 다운되므로)

### 수평적 규모 확장: scale-out

- 더 많은 서버를 추가하는 것

> 대규모 애플리케이션을 지원하는 데는 수평적 규모 확장이 더 적절하다.
> 

### 로드 밸런스

- 웹 서버들에게 ***트래픽 부하를 고르게 분산***하는 역할을 한다.
- 서버의 `가용성`을 향상
    - 서버 1이 다운되면 트래픽을 서버 2로 전송해 **전체가 다운되는 일 방지**
    - 트래픽이 가파르게 증가해도 **손 쉽게 서버 추가 가능**

### 데이터베이스 다중화

> 많은 DB 관리 시스템은 다중화를 지원한다. 보통, 서버 사이에 `master-slave` 관계를 설정하고 데이터 원본은 master 서버에, 사본은 slave 서버에 저장하는 방식이다.
> 
- 쓰기 연산은 master 서버에서만 지원
- slave 서버는 master로부터 사본을 전달 받으며, 읽기 연산만을 지원

💡 **대부분의 애플리케이션은 읽기 연산의 비중이 쓰기 연산보다 훨씬 높다.**

⇒ 따라서 통상 slave 데이터베이스가 master 데이터베이스보다 많다.

- **다중화의 이점**
1. `더 나은 성능`
    1. master / slave로 읽기와 쓰기 작업 부하 분산이 가능해 병렬로 처리할 수 있다.
2. `안정성`
    1. DB를 지리적으로 떨어진 거리에 두어 일부 DB가 파괴되어도 데이터는 보존 가능하다.
3. `가용성`
    1. 데이터를 여러 지역에 복사해두어, 하나의 서버가 다운되도 다른 서버에서 데이터를 가져와 사용할 수 있다.

<br>
<br>
<br>

## 캐시

> 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 둬 빨리 처리될 수 있도록 하는 저장소
> 

💡 **애플리케이션의 성능은 DB를 얼마나 자주 호출하느냐에 크게 좌우되는데, 캐시는 이런 문제를 완화시킬 수 있다.**

### 캐시 계층

- **`웹 서버 ↔ 캐시 ↔ DB`**
- 요청 받은 웹 서버는 캐시에 응답이 저장되어 있는지 본다.
- 만약 저장되어 있다면 바로 해당 테이터를클라이언트에 반환하고, 없으면 DB 질의를 통해 반환한다.
    - 읽기 주도형 캐시 전략

### 캐시 사용 시 유의할 점

1. 캐시는 갱신이 자주되지 않지만 참조가 빈번하게 발생하는 데이터에 적합
2. 캐시는 휘발성 메모리로, 재시작되면 캐시 내의 모든 데이터는 사라진다. 즉, 중요한 데이터는 캐시에 저장하면 안된다.
3. 만료 기간을 잘 설정해야 한다. 너무 짧으면 DB를 너무 자주 읽게 되고, 너무 길면 원본 데이터와 다를 수 있다.
4. 저장소의 원본 데이터를 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 데이터의 일관성이 깨질 수 있다. 이는 어려운 문제다.
5. 캐시 서버를 한 대만 두면 단일 장애 지점이 될 수 있으므로 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.
6. 캐시 메모리는 너무 작으면 데이터가 너무 캐시에서 밀려나버려 캐시의 성능이 떨어질 수 있다.
7. 캐시가 꽉 차버리면, 데이터 방출 정책(LRU, LFU, FIFO)를 사용해 기존의 데이터를 내보내야 한다.

<br>
<br>
<br>

## 콘텐츠 전송 네트워크 (CDN)

> 정적 콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버의 네트워크

- 이미지, CSS, JS, …
- 어떤 사용자가 웹사이트를 방문하면, 그 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달하게 된다.
- 고려해야 하는 점
    - 비용
    - 적절한 만료 시간
    - CDN 장애에 대한 대처 방안

<br>
<br>
<br>

## 무상태(stateless) 웹 계층

- 사용자의 세션 데이터와 같은 상태 정보는 웹 계층에서 제거해야 한다.
- 바람직한 전력
    - 상태 정보를 RDS나 NoSQL에 보관하고, 필요할 때 가져와 사용

<br>
<br>
<br>

## 데이터 센터

- 여러 개의 데이터 센터를 이용한다면
- 사용자는 가장 가까운 데이터 센터로 안내되는데, 이를 `지리적 라우팅`이라고 한다.
    
    > **사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할 지 결정할 수 있도록 해주는 DNS 서버**
    > 
- 이런 아키텍처를 만들기 위해서는 다음과 같은 난제를 해결해야 한다.
    - `트래픽 우회`: 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야 함 (ex. GeoDNS, …)
    - `데이터 동기화`

<br>
<br>
<br>

## 메시지 큐

- 메시지의 무손실(메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전하게 보관된다는 특성)을 보장하는, 비동기 통신을 지원하는 컴포넌트
- 흐름
    - 생산자/발행자가 메시지를 만들어 메시지 큐에 발행
    - 소비자/구독자가 해당 메시지를 받아 로직 수행
- 서버 간의 결합이 느슨해져, 규모 확작성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.

<br>
<br>
<br>

## 로그, 메트릭 그리고 자동화

- 시스템의 규모가 커질수록 로그 / 메트릭 / 자동화에 필수적으로 투자해야 한다.
- `로그`: 에러 로그를 모니터링하는 것은 중요
- `메트릭`: DB 성능, 캐시 성능, 일별 능동 사용자, 수익, 재방문, …
- `자동화`: 빌드, 테스트, 배포 등을 자동화하면 개발 생상성을 높일 수 음

<br>
<br>
<br>

## 데이터베이스의 규모 확장

### 수평적 확장

> 더 많은 서버를 추가해 성능을 향상시킬 수 있다. `샤딩`이라고도 부른다.
> 
- 샤딩이란
    - 샤드라고 부르는 작은 단위로 분할하는 기술
    - 모든 샤드는 같은 스키마를 쓰지만, 샤드에 보관되는 데이터 사이에는 중복이 없다.
    - ex) 사용자의 ID에 따라 어느 샤드에 넣을지 정함 → user_id % 4
- 샤딩 전략을 구현할 때 고려해야 할 가장 중요한 것은 샤딩 키를 어떻게 정하느냐 하는 것이다.
    - `샤딩 키(파티션 키)`: 데이터가 어떻게 분산될지 정하는 하나 이상의 컬럼으로 구성
    
    💡 **데이터를 고르게 분할 할 수 있도록 하는게 가장 중요**
    
<br>
<br>
<br>

## 백만 사용자, 그리고 그 이상

- 웹 계층은 무상태 계층으로
- 모든 계층에 다중화 도입
- 가능한 한 많은 데이터를 캐시할 것
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN을 통해 서비스할 것
- 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
- 각 계층은 독립적 서비스로 분할할 것
- 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것
