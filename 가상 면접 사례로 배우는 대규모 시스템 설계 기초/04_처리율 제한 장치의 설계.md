- `네트워크 시스템에서 처리율 제한 장치`: 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치
- ex) **특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한**
    - 사용자는 초당 2회 이상 새 글을 올릴 수 없다.
    - 같은 디바이스로는 주당 5회 이상 리워드를 요청할 수 없다.
- 이를 통해 DoS 공격에 의한 `자원 고갈 방지 가능`
- `비용 절감`
- `서버 과부하 방지`

<br>
<br>
<br>

## 1단계 문제 이해 및 설계 범위 확정

> 처리율을 구현하는데 여러 가지 알고리즘을 사용할 수 있는데, 각각 고유한 장단점을 가지고 있다.
> 
- 면접관에게 요구 사항에 대해 물어보면 어떤 제한 장치를 구현해야 하는지 분명히 알 수 있다.
- 요구 사항
    1. 설정된 처리율을 초과하는 요청은 정확하게 제한한다.
    2. 해당 처리율 제한 장치는 HTTP 응답 시간에 나쁜 영향을 주어서는 곤란한다.
    3. 가능한 한 적은 메모리를 사용해야 한다.
    4. 하나의 처리율 제한 장치를 여러 서버나 프로세스에서 공유할 수 있어야 한다.
    5. 요청이 제한되었을 때는 그 사실을 사용자에게 분명하게 보여줘야 한다.
    6. 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안된다.

<br>
<br>
<br>

## 2단계 개략적 설계안 제시 및 동의 구하기

> 기본적인 클라이언트-서버 통신 모델을 사용하자.
> 

### 처리율 제한 장치는 어디에 둘 것인가?

1. `클라이언트`: 클라이언트 요청은 쉽게 위변조가 가능해 적절하지 않다. 모든 클라이언트의 구현을 통제하는 것도 어려울 수 있다.
2. `서버`
3. `미들웨어`: 클라이언트 → API 서버 사이에 위치시켜 통제하도록 한다.

### 처리율 제한 알고리즘

1. `토큰 버킷`
2. `누출 버킷`
3. `고정 윈도 카운터`
4. `이동 윈도 로그`
5. `이동 윈도 카운터`

### 개략적인 아키텍처

> **레디스**는 처리율 제한 장치를 구현할 때 자주 사용되는 메모리 기반 저장장치
> 
> 
> [1] `INCR` 명령어: 메모리에 저장된 카운터의 값을 1만큼 증가시킴
> 
> [2] `EXPIRE` 명령어: 카운터에 타임아웃 값을 설정한다 설정된 시간이 지나면 카운터는 자동으로 삭제
> 

💡 클라이언트 → 처리율 위한 미들웨어 → 레디스 / API 서버

- 동작 원리
    - 클라이언트가 처리율 제한 미들웨어에게 요청을 보낸다.
    - 처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와 한도에 도달했는지 아닌지를 검사한다.
        - 한도에 도달했다면 요청을 거부
        - 한도에 도달하지 않았다면 요청은 API 서버로 전달, 한편 미들웨어는 카운터의 값을 증가시킨 후 다시 레디스에 저장

<br>
<br>
<br>

## 3단계 상세 설계

### 처리율 제한 규칙

- 리프트는 처리율 제한에 오픈 소스를 사용하고 있다.
- 처리율 제한 규칙 예제
    - 마켓팅 메시지의 최대치를 하루 5개로 제한
    
    ```java
    domain: messaging
    descriptions: 
      - key: message_type
        value: marketing
        rate_limit:
            unit: day
            requests_per_unit: 5
    ```
    
    - 분당 5회 이상 로그인할 수 없도록 제한
    
    ```java
    domain: auth
    descriptions: 
      - key: auth_type
        value: login
        rate_limit:
            unit: minute
            requests_per_unit: 5
    ```
    

### 처리율 한도 초과 트래픽의 처리

1. 한도 제한에 걸린 메시지를 나중에 처리하기 위해 큐에 보관할 수 있다.
2. 한도 제한에 걸린 요청은 버린다.
- 클라이언트는 자기 요청이 처리율 제한에 걸리고 있는지를 어떻게 감지할까?
    - **HTTP 응답 헤더**를 통해 알 수 있다.
    - 이번 장에 설계하는 처리율 제한 장치는 다음의 HTTP 헤더를 클라이언트에게 보낸다.
    - `X-Ratelimit-Remaining`: 윈도 내에 남은 요청 처리 가능 요청 수
    - `X-Ratelimit-Limit`: 매 윈도마다 클라이언트가 전송할 수 있는 요청 수
    - `X-Ratelimit-Retry-After`: 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야 하는지 알림
- 사용자가 너무 많은 요청을 보내면 429 too many requests 오류를 X-Ratelimit-Retry-After 헤더와 함께 반환하도록 한다.
- (전체적인 아키텍처는 그림 4-13 참고)
- 처리율 제한 규칙은 디스크에 보관

### 분산 환경에서의 처리율 제한 장치의 구현

- 여러 대의 서버와 병렬 스레드를 지원하도록 시스템을 확장하는 것은 또 다른 문제다. 아래 2문제를 해결해야 한다.
1. ***경쟁 조건***
    1. 락으로 해결할 수 있지만, 락은 시스템의 성능을 상당히 떨어뜨린다.
    2. 대신, `루아 스크립트` or `정렬 집합이라 불리는 레디스 자료구조`를 써보자.
2. ***동기화***
    1. 고정 세션을 활용해 문제를 해결할 수 있다. 하지만, 규모면에서 확장 가능하지도 않고 유연하지도 않다.
    2. 대신, `레디스`와 같은 `중앙 집중형 데이터 저장소`를 써보자.
    3. (전체적인 아키텍처는 그림 4-16 참고)
    

### 성능 최적화

> 지금까지 살펴 본 설계는 2가지 지점에서 개선 가능하다.
> 
1. 사용자의 트래픽을 `가장 가까운 에지 서버`로 전달하여 지연 시간을 줄이자.
2. 제한 장치 간 에 데이터를 동기화할 떄 `최종 일관성 모델`을 사용하자. (6장 “키-값 저장소 설계”의 “데이터 일관성”을 참고)

### 모니터링

- 처리율 제한 장치를 설치한 이후에는 효과적으로 동작하는지 보기 위해 데이터를 모을 필요가 있다.
- 기본적으로 다음 2가지를 확인
    1. ***채택된 처리율 제한 알고리즘이 효과적인가***
    2. ***정의한 처리율 제한 규칙이 효과적인가***
- 만약, 처리율 제한 규칙이 너무 빡빡하게 설정되어 있어 많은 유효 요청이 처리되지 못하고 버려진다면 완화할 필요가 있다.

<br>
<br>
<br>

## 4단계 마무리

- 시간이 남았다면 다음과 같은 부분을 언급해보면 도움이 될 것
1. 경성 또는 연성 처리율 제한
    1. 경성 처리율 제한: 요청의 개수는 임계치를 절대 넘어설 수 없다.
    2. 연성 처리율 제한: 요청의 개수는 잠시 동안은 임계치를 넘어설 수 있다.
2. 다양한 계층에서의 처리율 제한
    1. 이번 장에서는 애플리케이션 계층(HTTP)에서 살펴보았지만, 물리 / 데이터 링크 / 네트워크 / 전송 / 세션 / 표현 계층에서도 적용 가능하다.
3. 처리율 제한을 회피하는 방법. 클라이언트를 어떻게 설계하는 것이 최선인가?
    1. 클라이언트 측 캐시를 사용해 API 호출 횟수를 줄인다.
    2. 짧은 시간동안 너무 많은 메시지를 보내지 않도록 한다.
    3. 예외나 에러를 처리하는 코드를 도입하여 클라이언트가 예외적인 상황으로부터 우아하게 복구될 수 있도록 한다.
    4. 재시도 로직을 구현할 때는 충분한 백오프 시간을 둔다.
