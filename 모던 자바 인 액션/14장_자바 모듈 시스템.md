## 14.1 입력 : 소프트웨어 유추

추론하기 쉬운 소프트웨어를 만든느데 도움을 주는 `관심사 분리`와 `정보 은닉`이 있다.

### 관심사 분리

> **컴퓨터 프로그램을 고유 기능으로 나누는 동작을 권장하는 원칙**
> 

⇒ 클래스를 그룹화한 모듈을 이용해 애플리케이션의 클래스 간의 관계(`의존성`)를 시각적으로 보여줄 수 있다.

### 정보 은닉

> **세부 구현을 숨기도록 장려하는 원칙**
> 

⇒ 요구사항은 자주 바뀐다. 세부 구현을 숨김으로 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있다. 즉 `캡슐화` (코드를 관리하고 보호하는데 유용)

<br>

## 14.2 자바 모듈 시스템을 설계한 이유

자바 9이전까지는 모듈화된 소프트웨어 프로젝트를 만드는데 한계가 있었다.

[1] `제한된 가시성`: 다양한 클래스 그룹을 정의한 여러 패키지의 가시성 제어를 접근 제한자로만 하는 것은 어렵다.

[2] `클래스 경로`: 같은 클래스를 구분하는 버전 개념이 없다. 그리고 명시적인 의존성을 지원하지 않는다.

<br>

## 14.3 자바 모듈 : 큰 그림

자바 8의 모듈는 **자바 프로그램 구조 단위를 제공**한다,

`모듈 디스크립터`는 module-info.java라는 특별한 파일에 저장된다. 그리고 보통 패키지와 같은 폴더에 위치하며 한 개 이상의 패키를 서술하고 캡슐화 가능하다.

### exports 구문

> 다른 모듈에서 사용할 수 있도록 특정 패키지를 공개 형식으로 만든다.
> 

```java
module expenses.readers {
	exports com.example.expenses.readers; // 패키지명을 적어준다.
	exports com.example.expenses.readers.file; // ""
	exports com.example.expenses.readers.http; // ""
}
```

### requires 구분

> 의존하고 있는 모듈을 지정한다.
> 

```java
module expenses.readers {
	requires jaba.base; // 해당 모듈은 자바 메인 패키지(io, util, ...)를 포함

	exports com.example.expenses.readers;
	exports com.example.expenses.readers.file;
	exports com.example.expenses.readers.http;
}
```

### 이름 정하기

패키지명처럼 `인터넷 도메인명을 역순`으로 모듈의 이름을 정하도록 권고한다. 더욱이 모듈명은 **노출된 주요 API 패키지와 이름이 같아야 한다는 규칙**도 따라야 한다.

> ex) com.iteratrlearning.training
> 

<br>

## 14.7 자동 모듈

모듈 경로상에 있으나 module-info 파일을 가지지 않은 모든 JAR는 자동 모듈이 된다. 자동 모듈은 암묵적으로 자신의 모든 패키지를 노출시킨다. 자동 모듈의 이름은 JAR 이름을 이용해 정해진다. (변경 가능)

<br>

## 14.10 마치며

- 관심사 분리와 정보 은닉은 추론하기 쉬운 소프트웨어를 만드는 중요한 두 가지 원칙
- 자바 9 이전에는 각각의 기능을 담당하는 패키지, 클래스, 인터페이스로 모듈화를 구현
  - 하지만, 효과적인 캡슐화를 달성하기에는 역부족이었다.
- 자바 9에서는 새로운 모듈 시스템을 제공하는데 module-info.java 파일은 모듈의 이름을 지정하며 필요한 의존성(requires)과 공개 API(exports)를 정의한다.
- 인터넷 도메인명을 역순으로 사용하는 것이 권장 모듈 이름 규칙이다.
- 모든 경로에 포함된 JAR 중에 module-info 파일을 포함하지 않는 모든 JAR는 자동 모듈이 된다.
  - 자동 모듈은 암묵적으로 모든 패키지를 공개한다.
