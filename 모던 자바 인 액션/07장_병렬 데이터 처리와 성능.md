스트림을 이용하면 순차 스트림을 병렬 스트림을 자연스럽게 바꿀 수 있다. 단, 병렬 스트림이 어떻게 처리되는지 알아야만 스트림을 잘못 사용하는 상황을 피할 수 있다.

<br>

## 7.1 병렬 스트림

컬렉션에 `parallelStream`을 호출하면 `병렬 스트림`이 생성된다. 병렬 스트림이란 **각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림**이다. 그래서 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.

- 주어진 숫자만큼 모든 숫자를 더하는 예시

```java
public long sequentialSum(long n) {
  return Stream.iterate(1L, i -> i + 1)
               .limit(n)
               .reduce(0L, Long::sum); // 모든 숫자를 더하는 스트림 리듀싱 연산
}
```

반복문으로도 구현 가능하다.

```java
public long iterativeSum(long n) {
  long result = 0;
  for(long i = 1L; i <= n; i++) {
    result += i;
  }
  return result;
}
```

> n이 커진다면 해당 연산을 병렬로 처리하는 것이 좋을 것이다.
> 

병렬 스트림을 이용하면 아래에 문제들을 쉽게 해결할 수 있다.

- 무엇부터 건드려야 할까? 결과와 변수는 어떻게 동기화해야 할까? 몇 개의 스레드를 사용해야 할까? 숫자는 어떻게 생성할까? 생성된 숫자는 누가 더할까?

### 순차 스트림을 병렬 스트림으로 변환하기

`parallel` 메서드를 호출하면 리듀싱 연산을 **여러 청크에 병렬로 수행**할 수 있다. 마지막으로 리듀싱 연산으로 생성된 부분 결과를 **다시 리듀싱 연산으로 합쳐서 전체 스트림의 리듀싱 결과를 도출**한다.

```java
public long parallelSum(long n) {
  return Stream.iterate(1L, i->i+1) 
               .limit(n)
               .parallel() // 스트림 -> 병렬 스트림
               .reduce(0L, Long::sum);
}
```

순차 스트림에 `parallel`을 호출해도 스트림 자체에는 아무런 변화도 일어나지 않고, 내부적으로는 연산이 병렬로 수행해야 함을 의미라는 불리언 플래그가 설정된다. 반대로 `sequential`로 병렬 스트림을 순차 스트림으로 바꿀 수 있다.

### 스트림 성능 측정

성능을 최적화할 때는 첫째도 측정, 둘째도 측정, 셋째도 측정이다. JMH라는 라이브러를 이용해 작은 벤치마크를 구현해보자.

- n개의 숫자를 더하는 함수의 성능 측정

예상치 못한 결과가 나왔다. 두 가지 문제가 있다.

1. 반복 결과로 박싱된 객체가 만들어지므로 숫자를 더하려면 언박싱을 해야 한다.
2. 반복 작업은 병렬로 수행할 수 있는 독립 단위로 나누기가 어렵다. (전체 숫자 리스트가 준비되지 않아 청크로 분할할 수 없다.)

> 이처럼 병렬 프로그래밍은 까다롭고 때로는 이해하기 어려운 함정이 숨어있다.
> 

### 더 특화된 메서드 사용

위의 parallelSum()을 효과적으로 사용하려면 다음과 같이 코드를 고칠 수 있다.

- LongStream을 사용해 박싱과 언박싱 오버헤드가 사라진다.
    
    ⇒ 이를 통해 때로는 병렬화를 하는 것보다 **적절한 `자료구조`를 선택하는 것이 더 중요**하다.
    
- rangeClosed로 숫자 범위를 생산해 쉽게 청크로 분할할 수 있어진다.

```java
public static long parallelRangedSum(long n) {
    return LongStream.rangeClosed(1, n)
                     .parallel()
                     .reduce(0L, Long::sum);
}

// Score: 2
```

하지만, 병렬화가 완전 공짜는 아니다. 스트림을 재귀적으로 분할해야 하고, 각 서브 스트림을 서로 다른 스레드의 리듀싱 연산으로 할당하고, 이들 결과를 하나의 값으로 합쳐야 한다.

> 멀티코어 간의 데이터 이동은 우리 생각보다 비싸므로 코어 간에 데이터 전송 시간보다 훨씬 오래 걸리는 작업만 병렬로 수행시키는 것이 바람직하다.
> 

### 병렬 스트림의 올바른 사용법

```java
public class Accumulator {
    public long total = 0;
    public void add(long value) { total += value; }
}

public static long sideEffectParallelSum(long n) {
    Accumulator accumulator = new Accumulator();
    LongStream.rangeClosed(1, n).parallel().forEach(accumulator::add);
    return accumulator.total;
}
```

위 코드를 실행해보면 올바른 결과 값이 나오지 않는다. 이유는 여러 스레드에서 동시에 누적자, 즉 **total += value를 실행**하기 때문이다. (여러 스레드에서 공유하는 객체의 상태를 바꾼다.)

💡 **병렬 스트림이 올바로 동작하려면 공유된 `가변 상태`를 피해야 한다는 사실을 알고 있자.**

### 병렬 스트림 효과적으로 사용하기

- 언제나 병렬 스트림이 순차 스트림보다 빠른 것은 아니기 때문에 적절한 벤치마크로 **직접 성능을 측정하고 사용하자.**
- **박싱을 주의**하자. 이를 위해 **기본형 특화 스트림을 제공**한다.
- 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다. ex) limit, findFirst
- 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라. 처리해야 할 요소 수가 N, 하나의 요소를 처리하는 데 드는 비용을 Q하 하면 스트림 파이프라인 처리 비용은 N*Q로 예상할 수 있다. **Q가 높아진다는 것은 병렬 스트림으로 성능을 개선할 수 있는 가능성이 있음을 의미**한다.
- **소량의 데이터**에서는 병렬 스트림이 도움되지 않는다.
- 스트림을 구성하는 **자료구조가 적절한지 확인**하라. ex) LinkedList를 분할하려면 모든 요소를 탐색해야 하지만 ArryList는 요소를 탐색하지 않고도 리스트를 분할할 수 있기 때문이다.
- **스트림의 특성**과 **파이프라인의 중간 연산**이 스트림의 특성을 어떻게 바꾸는지에 따라 **분해 과정의 성능이 달라질 수 있다.** ex) 필터 연산이 있으면 스트림의 길이를 예측할 수 없으므로 효과적으로 병렬 처리를 할 수 없게 된다.
- **최종 연산의 병합 과정 비용을 살펴보라.** 병합 과정의 비용이 비싸면 병렬 스트림으로 얻은 이익이 상쇄될 수 있다.

<br>

## 7.2 포크/조인 프레임워크

포크/조인 프레임워크는 병렬화 할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었다.

### Recursive Task 활용

스레드 풀을 만들려면 `RecursiveTask<R>`의 서브클래스를 만들어야 한다. 여기서 R은 병렬화된 태스크가 생성하는 결과 형식 또는 결과가 없을 때는 RecursiveAction 형식이다.

```java
protected abstract R compute();
```

`compute` 메서드는 **태스크를 서브태스크로 분할하는 로직과 더 이상 분할할 수 없을 때 개별 서브태스크의 결과를 생산할 알고리즘을 정의**한다.

```java
// 의사 코드 형식
if(태스크가 충분히 작거나 더 이상 분할할 수 없으면) {
    순차적으로 태스크 계산
} else {
    태스크를 두 서브태스크로 분할
    태스크가 다시 서브태스크로 분할되도록 이 메서드를 재귀적으로 호출함
    모든 서브태스크의 연산이 완료될 때까지 기다림
    각 서브태스크의 결과를 합침
}
```

### 포크/조인 프레임워크 제대로 사용하는 방법

- join 메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될 때까지 호출자를 블록시킨다. 따라서 두 서브태스크가 모두 시작된 다음에 join을 호출해야 한다. 그렇지 않으면 기다리게 되어 느려질 수 있다.
- RecursiveTask 내에서는 ForkJoinPool의 invoke 메서드를 사용하지 말아야 한다. 대신 compute나 fork 메서드를 직접 호출 가능
    - 순차 코드에서 병렬 계산을 시작할 때만 invoke를 사용한다.
- 서브태스크에 fork 메서드를 호출해서 ForkJoinPool의 일정을 조절할 수 있다. 왼쪽 오른쪽 작업 모두에 fork 메서드를 호출하는 것보다 한쪽 작업에는 compute를 호출하는 것이 효율적이다.
    - 그러면 두 서브 태스크의 한 태스크에는 같은 스레드를 재사용할 수 있어 풀에서 불필요한 태스크를 할당하는 오버헤드를 피할 수 있다.
- 포크/조인 프레임워크를 이용하는 병렬 계산은 디버깅하기 어렵다.
- 멀티코어에 포크/조인 프레임워크를 사용하는 것이 순차 처리보다 무조건 빠를 거라는 생각은 버려야 한다.
    - 각 서브태스크의 실행시간은 새로운 태스크를 포킹하는데 드는 시간보다 길어야 한다.
    - 컴파일러 최적화는 병렬 버전보다는 순차 버전에 집중될 수 있다는 사실도 기억하자.

### 작업 훔치기

이 기법에서는 ForkJoinPool의 모든 스레드를 거의 공정하게 분할한다. 각각의 스레드는 자신에게 할당된 태스크를 포함하는 이중 연결 리스트를 참조하면서 **작업이 끝날 때마다 큐의 헤드에서 다른 태스크를 가져와서 작업을 처리**한다.

자신에게 할당된 태스크를 더 빨리 처리한 스레드가 유휴 상태로 바뀌지 않고 다른 스레드 큐의 꼬리에서 작업을 훔쳐온다. 모든 태스크가 작업을 끝낼 때까지, 즉 모든 큐가 빌 때까지 이 과정을 반복함.

<br>

## 7.3 Spliterator 인터페이스

Iterator처럼 Spliterator는 소스의 요소 탐색 기능을 제공한다는 점은 같지만 **Spliterator는 병렬 작업에 특화**되어 있다. 자바 8은 컬렉션 프레임워크에 포함된 모든 자료구조에 사용할 수 있는 `디폴트 Spliterator` 구현을 제공한다.

```java
public interface Spliterator<T> {
    // 요소를 하나씩 순차적으로 소비하면서 탐색해야 할 요소가 남아있으면 참을 반환
    boolean tryAdvance(Consumer<? super T> action);
    // Spliterator의 일부 요소를 분할해서 두 번째 Spliterator를 생성하는 메서드
    Spliterator<T> trySplit();
    // 탐색해야 할 요소 수 정보 제공
    long estimateSize();
    // Spliterator 자체의 특성 집합을 포함하는 int를 반환
    // 이 특성을 참고해 Spliterator를 더 잘 제어하고 최적화 가능
    int characteristics();
}
```

### 분할 과정

재귀적으로 일어난다. 첫 번째 Spliterator에 trySplit()를 호출하면 두 번째 Spliterator가 생성되고 trySplit()의 결과가 null이 될 때까지 이 과정을 반복한다. 모든 trySplit() 결과가 null이면 재귀 분할 과정이 종료된다. (이 분할 과정은 characteristics 메서드로 정의하는 Spliterator의 특성에 영향을 받는다.)

<br>

## 7.4 마치며

- **내부 반복**을 이용하면 명시적으로 다른 스레드를 사용하지 않고도 스트림을 병렬로 처리 가능
- **항상 병렬 처리가 빠른 것은 아니다.** 병렬 처리를 사용했을 때 성능을 직접 측정해보자.
- 데이터 집합을 병렬 실행할 때 특히 **처리해야 할 데이터가 아주 많거나,** **각 요소를 처리하는데 오랜 시간이 걸릴 때** 성능을 높일 수 있다.
- 가능하면 **기본형 특화 스트림**을 사용하는 등 **올바른 자료구조 선택이 어떤 연산을 병렬로 처리하는 것보다 성능적으로 더 큰 영향을 미칠 수 있다.**
- **포크/조인 프레임워크**는 병렬화할 수 있는 테스크를 **작은 테스크로 분할**한 다음에 분할된 테스크를 **각각의 스레드로 실행**하며 서브 태스크 각각의 **결과를 합쳐 최종 결과를 생산**
- Spliterator는 스트림을 어떻게 병렬화할 것인지 정의함
