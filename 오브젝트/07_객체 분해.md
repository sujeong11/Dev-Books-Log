## 01 프로시저 추상화와 데이터 추상화

`프로시저 추상화`: 소프트웨어가 무엇을 해야 하는지를 추상화

`데이터 추상화`: 소프트웨어가 무엇을 알아야 하는지를 추상화

`프로그래밍 패러다임`: 적절한 추상화의 윤곽을 따라 시스템을 어떤 식으로 나눌 것인지를 결정하는 원칙과 방법의 집합

현대의 설계 방법에 중요한 영향을 끼치는 프로그래밍 패러다임들은 프로시저 추상화나 데이터 추상화를 중심으로 시스템의 분해 방법을 설명한다.

- 프로시저 추상화를 중심으로 시스템을 분해하기로 결정
    - 이는 `기능 분해`의 길로 들어서는 것 (알고리즘 분해라고 부르기도 함)
- 데이터 추상화를 중심으로 시스템을 분해하기로 결정
    - 다시 두 가지 중 하나를 선택해야 한다.
    -  타입 추상화 → `추상 데이터 타입`
    -  데이터를 중심으로 프로시저를 추상화 → `객체지향`

> 객체지향이란 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체(객체를 구현한 클래스)를 이용해 시스템을 분해하는 방법
> 

<br>
<br>

---

<br>

## 02 프로시저 추상화와 기능 분해

### 메인 함수로서의 시스템

기능은 오랜 시간동안 시스템을 분해하기 위한 기준으로 사용되었다. 

- 추상화의 단위는 프로시저로 반복 / 유사하게 실행되는 작업을 하나에 모아두어 로직을 재사용하고 중복을 방지할 수 있다.
- 프로시저 추상화는 구현 내용을 몰라도 인터페이스만 알면 사용할 수 있어 정보은닉 기능이 있지만 이 프로시저만으로는 정보은닉 체계를 구축하는데는 한계가 있다.

전통적인 분해 방법: `하향식 접근법` (Top-Down)

시스템을 구성하는 가장 최상위 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법이다. 다시 말해 하위 기능은 상위 기능보다 덜 추상적이어야 한다.

<br>

### 하향식 기능 분해의 문제점

> 설계는 코드 배치 방법으로 변경을 대비하기 위한 것이다.
> 

하지만, 하향식 접근법과 기능 분해의 **근본적인 문제는 변경에 취약한 설계를 낳는다는 것**이다. 문제점들에 대해 알아보자.

1. **시스템은 하나의 메인 함수로 구성돼 있지 않다.**

    모든 기능을 가진 자식 노드로 가지는 하나의 메인 기능을 선택하는 것은 매우 어렵다. (시스템에 정상은 존재하지 않는다.)

2. **기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.**

    새로운 기능을 추가할 때마다 매번 메인 함수의 구조를 수정해야 한다. 기존 코드를 수정하는 것은 새로운 버그를 만들어 낼 수 있는 확률을 높여 시스템을 변경에 취약해지도록 만든다.

3. **비지니스 로직이 사용자 인터페이스와 강하게 결합한다.**

    사용자 인터페이스(ex. 사용자에게 입력 값을 받음)는 시스템 내에서 자주 변경되는 부분인 반면 비지니스 로직(입력 받은 값으로 계산 수행)은 변경이 비교적 적게 발생한다. **이런 둘이 로직 안에 섞기기 때문에 하나의 변경이 또 다른 하나의 변경으로 까지 영향을 주게 된다.** 즉, 변경에 불안정해진다.

4. **하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.**

    함수를 작은 함수로 계속 분해하기 때문에 시스템이 무엇을 해야 하는지가 아닌 어떻게 동작해야 하는지에 집중하도록 만든다. 그리고 실행 순서를 미리 결정하지 않으면 기능 분해를 할 수 없다. → 중앙 집중 제어 스타일의 형태를 띄게 된다.

    이로 인해 하위 함수는 상위 함수의 흐름에 따라 적절한 시점에 호출될 뿐이다. **하위 함수는 상위 함수에 종속**되므로 재사용이 떨어지고 유연하지 않다.

5. **데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.**

    **어떤 함수가 어떤 데이터를 사용하고 있는지 추적하기 어렵다**보니 데이터의 변경이 어느 함수에 영향을 줄지 알기 어렵다. 만약, 알고 싶다면 모든 함수를 열어 확인해야 한다.

    데이터 변경에 대한 영향을 최소한 하기 위해서는 **영향을 받는 부분과 받지 않는 부분을 명확하게 분리하고 퍼블릭 인터페이스를 통해 접근을 잘 통제해 한다.** (이런 문제를 해결하기 위해 정보 은닉과 모듈이라는 개념이 등장했다.)

<br>

### 언제 하향식 분해가 유용한가?

> 시스템이나 프로그램 개발자가 이미 완료한 결과에 대한 명확한 아이디어를 가지고 있다면 머릿속에 있는 것을 종이에 서술하기 위해 하향식을 사용할 수 있다.
> 

프로그래밍 과정에서 이미 해결된 알고리즘을 문서화하고 서술하는데 휼륭한 기법이다.

<br>
<br>

---

<br>

## 03 모듈

### 정보 은닉과 모듈

시스템의 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현 단위로 묶고 퍼블릭 인터페이스를 통해 접근하도록 만드는 것이다.→ `변경 방향에 맞춰 시스템을 분해`

- `정보 은닉`: 시스템을 모듈 단위로 분해하기 위한 기본 원리, **시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것**이 핵심
- `모듈`: **책임의 할당**, **모듈화는 개별적인 모듈에 대한 작업이 시작되기 전에 정해져야 하는 설계 결정들을 포함**
    - **기능 분해 vs 모듈 분해**: 전자는 필요한 기능을 순차적으로 찾아가는 탐색 과정인 반면 **후자는 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 과정**
    - 아래 두 가지 비밀을 감춰야 한다.
    - `복잡성`: 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낯춘다.
    - `변경 가능성`: 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.
    - 시스템의 가장 일반적인 비밀은 데이터이다. (복잡한 구조, 변경 가능성이 큰 자료구조, …)

<br>

### 모듈의 장점과 한계

- 장점

[1] **모듈의 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.**

[2] **비지니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.**

[3] **전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.**

모듈은 변경 정도에 따라 시스템을 분해함으로 **각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합**이다. 따라서 모듈 내부는 `높은 응집도`를 유지한다. **모듈과 모듈은 퍼블릭 인터페이스를 통해서만 통신**해야 하므로 `낮은 결합도`를 유지한다.

⇒ 모듈이 정보 은닉이라는 개념을 통해 데이터라는 존재를 설계의 중심 요소로 부각시켰다. 즉, 핵심은 `데이터`다.

- 단점

> 모듈은 감춰야 할 데이터를 결정하고 이 데이터를 조작하는데 필요한 함수를 결정한다. 즉, **데이터를 중심으로 시스템을 분할**한다. 
> → **모듈은 데이터와 함수가 통합된 한 차원 높은 추상화를 제공하는 설계 단위**다. 

[1] **추상화 관점에서 한계점이 명확하다.**

[2] **인스턴스 개념을 제공하지 않는다.**

ex. Employee 모듈은 회사에 속한 모든 직원을 가지고 있는 모듈일 뿐 **개별 직원을 독립적인 단위로 다룰 수 없다.**

(이를 해결하기 위해 등장한 개념이 추상 데이터 타입이다.)

<br>
<br>

---

<br>

## 04 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입

프로시저 추상화를 보완하기 위해 데이터 추상화의 개념이 등장했다. 추상 데이터 타입을 구현하기 위해서는 다음과 같은 프로그래밍 언어의 지원이 필요하다.

[1] 타입 정의를 선언할 수 있어야 한다.

[2] 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.

[3] 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.

[4] 타입에 대해 여러 개의 인스턴스를 생성 할 수 있어야 한다.

⇒ 내장 데이터 타입과 동일하다. 단, 개발자가 타입을 정의할 수 있다는 점만 다를 뿐이다.

- 루비로 작성한 추상 데이터 타입 예시

> 상태와 행위를 가지는 독립적인 객체를 생성할 수 있다.

```ruby
Employee = Struct.new(:new, :basePay, :hourly, :timeCard) do
End
```

하지만, 여전히 **데이터와 기능을 구분**해서 바라보고 있다. 이는 **절차적인 설계의 틀**에 갇혀있는 것이다.

<br>
<br>

---

<br>

## 05 클래스

### 클래스는 추상 데이터 타입인가?

> 명확한 의미에서 둘은 동일하지 않다.
> 

| - | 클래스 | 추상 데이터 타입 |
| --- | --- | --- |
| 상속과 다형성을 지원 유 / 무 | O | X |
| 추상화 대상 | 타입을 기준으로 절차들을 추상화 | 오퍼레이션을 기준으로 타입을 추상화 |
| 예시 비교 | 정규 직원 / 알바 직원에 대해 각각의 클래스를 정의하고 필요한 오퍼레이션을 구현 | Emplyee 타입 안에 정규 직원 / 알바 직원을 포함해 세부적인 타입을 감춘다. |
|  | 다형성을 지원하므로 공통 기능은 부모 클래스를 상속받게 할 수 있다. (다형성 지원) |  |

클래스를 이용한 다형성은 **절차에 대한 차이점을 감춘다.** 즉, 객체지향은 `절차 추상화`다.

<br>

### 추상 데이터 타입에서 클래스로 변경하기

Employee를 추상 클래스로 만들고, 공통 기능의 시그니처로 추상 메서드를 선언한다.

이 추상 클래스를 상속받은 SalariedEmployee와 HourlyEmployee 클래스를 생성해 각 클래스에 필요한 로직만 구현한다.

> 이제 sumOfBasePays 메서드는 객체가 어떤 타입인지 고민하지 않고 monthlyBasePay에 메시지를 전송하는 것에 주목하라.
> 
> 
> (메시지를 수신한 객체는 자신의 클래스에 구현된 메서드를 이용해 적절하게 반응할 수 있다.)
> 

<br>

### 변경을 기준으로 선택하라

> 클래스를 구현 단위로 사용하고 있다는 것이 객체지향 프로그래밍을 의미하지 않는다.
> 

**타입을 기준으로 절차를 추상화하지 않았다면 그것은 객체지향 분해가 아니다.**

**인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것이다.**

- 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다. (조건문을 기피하는 것은 변경 때문)
    - 즉, 클라이언트가 객체 타입을 확인 후 적절한 메서드를 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택한다.
    
    - 이로 인해 새로운 로직을 추가해도 클래스 하나만 추가하면 되고 클라이언트 코드를 수정할 필요가 없다.
        
        → `개방-폐쇄 원칙`: 기존 코드에 아무런 영향을 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성
        
<br>

### 항상 절차를 추상화하는 객체지향 설계 방식을 따라야 하는가?

> 아니다.
> 

**설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다.** 

- `새로운 타입을 빈번하게 추가`해야 한다면 `객체지향 클래스 구조`가 더 유용
- `새로운 오퍼레이션을 빈번하게 추가`해야 한다면 `추상 데이터 타입`이 더 유용

<br>

### 협력이 중요하다

**객체가 참여할 협력을 결정하고 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지에 관해 고민하라. 그 책임을 다양한 방식으로 수행해야 할 때만 타입 계층 안에 각 절차를 추상화하라.**

**타입 계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 하며 그 자체가 목적이 되어서는 안된다.**
