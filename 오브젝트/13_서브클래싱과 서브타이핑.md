## 01 타입

### 개념 관점의 타입

개념 관점에서의 타입이란 우리가 인지하는 세상의 사물의 종류를 의미한다. 즉, 우리가 인식하는 객체들에 적용하는 개념이나 아이디어를 가리킨다.

- [ex] 자바, C, …는 프로그래밍이라는 언어의 타입으로 분류
    - 자바, C, …는 타입의 `인스턴스`라고 한다.
    - 일반적으로 타입의 인스턴스를 `객체`라고 부른다.
- 타입은 심볼, 내연, 외연의 세 가지 요소로 구성된다.

<br>

### 프로그래밍 언어 관점의 타입

프로그래밍 언어 관점에서 타입은 연속적인 비트(0, 1)에 의미와 제약을 부여하기 위해 사용된다. 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 전적으로 데이터를 사용하는 어플리케이션에 의해 결정된다.

즉, **타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용**한다.

<br>

### 객체지향 패러다임 관점의 타입

객체지향 프로그래밍에서 오퍼레이션은 **객체가 수신할 수 있는 메시지**를 의미한다. 따라서 객체의 타입이란 **객체가 수신할 수 있는 메시지의 종류(**`퍼블릭 인터페이스`**)를 정의하는 것**이다.

> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.
> 

객체에게 중요한 것은 속성이 아니라 `행동`이다. **어떤 객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르면 이들은 서로 다른 타입으로 분류**된다. 반대로 어떤 객체들이 내부 상태는 다르지만 동일한 퍼블릭 인터페이스를 공유한다면 이들은 동일한 타입으로 분류된다.

- 객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다. **객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 외부에 제공하는 행동이라는 사실을 기억하자.**

<br>
<br>

---

<br>

## 02 타입 계층

### 타입 사이의 포함관계

타입 계층을 표현할 때는 더 일반적인 타입을 위쪽에, 더 특수한 타입을 아래쪽에 배치하는 것이 관계다.

- `슈퍼타입`: 더 일반적인 타입
    - 집합이 다른 집합의 모든 멤버를 포함한다.
- `서브타입`: 더 특수한 타입
    - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.

<br>

### 객체지향 프로그래밍과 타입 계층

객체의 타입을 결정하는 것은 `퍼블릭 인터페이스`다.

- `일반적인 타입`: 비교하려는 타입에 속한 객체들의 **퍼블릭 인터페이스보다 더 일반적인 퍼블릭 인터페이스** 가진 객체들의 타입
- `특수한 타입`: 비교하려는 타입에 속한 객체들의 **퍼블릭 인터페이스보다 더 특수한 퍼블릭 인터페이스** 가진 객체들의 타입

즉, **서브 타입의 인스턴스는 슈퍼 타입의 인스턴스로 간주될 수 있다.**

<br>
<br>

---

<br>

## 03 서브클래싱과 서브타이핑

### 언제 상속을 사용해야 하는가?

> 상속의 올바른 용도는 타입 계층을 구현하는 것
> 

마틴 오더스키는 다음과 같은 질문을 해보고 모두 ‘예’라고 답할 수 있는 경우에만 상속을 사용하라고 한다.

- [1] **상속 관계가 is-a 관계를 모델링하는가?**
    
    즉, “[자식 클래스]는 [부모 클래스]다”라고 말해도 이상하지 않아야 한다.
    
- [2] **클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?**
    
    즉, 상속 게층을 사용하는 **클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다.** 이를 자식 클래스와 부모 클래스 사이의 `행동 호환성`이라고 부른다.
    

설계 관점에서는 두 번째 질문에 초점을 맞추는 것이 중요하다.

<br>

### is-a 관계

“타입 S는 타입 T다”

[ ex ] 객체지향 언어는 프로그래밍 언어다. 클래스 기반 언어는 객체지향 언어다.

- 단, 이런 관계가 명쾌한 것은 아니다.

[ ex ] 펭귄은 분명 새지만 날 수 없는 새다.

```java
public class Bird {
	public void fly() { ... }
		...
}

public class Peguin extends Bird {
	...
}
```

위 예시로 인해 **어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다는 사실을 잘 보여준다.** 새가 정의에 **날 수 있다는 행동이 포함되지 않는다면** 펭귄은 새의 서브타입이 될 수 있다. 이 경우에는 **어휘적인 관점과 행동 관점이 일치**하게 된다.

따라서 **타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.** 그에 따라 **올바른 타입 계층이라는 의미 역시 문맥에 따라 달라질 수 있다.**

<br>

### 행동 호환성

타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 하더라도 **행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다.**

중요한 것은 행동의 호환 여부를 판단하는 기준은 `클라이언트의 관점`이다. 클라이언트가 두 타입이 **동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.**    

<br>

### 클라이언트의 기대에 따라 계층 분리하기

클라이언트에 따라 인터페이스를 분리하면 **각 클라이언트의 요구가 바뀌더라도 영향의 파급 효과를 효과적으로 제어**할 수 있게 된다. 이처럼 **인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙**을 `인터페이스 분리 원칙`이라고 부른다.

사실, 설계가 꼭 현실 세계를 반영할 필요는 없다. 중요한 것은 **설계가 반영할 도메인의 요구사항이고 그 안에서 클라이언트가 객체에게 요구하는 행동**이다. 즉, 두 클래스 사이에 행동이 호환되지 않는다면 올바른 타입 계층이 아니기 때문에 상속을 사용해서는 안된다.

<br>

### 서브클래싱과 서브타이핑

- 상속의 두 가지 목적을 다시 생각해보자.
    - 코드 재사용
    - 타입 계층을 구성하기 위해
- `서브 클래싱`: **다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우**
    - 자식 클래스와 부모 클래스의 **행동이 호환**되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 **대체할 수 없다.**
    - `구현 상속` / `클래스 상속`이라고 하기도 한다.
- `서브 타이핑`: **타입 계층을 구성하기 위해 상속을 사용하는 경우**
    - 자식 클래스와 부모 클래스의 **행동이 호환**되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 **대체할 수 있다.** → `행동 호환성`을 만족시켜야 한다. (부모 클래스에 대한 자식 클래스의 `대체 가능성`을 포함)
    - `인터페이스 상속`이라고 하기도 한다.

<br>
<br>

---

<br>

## 04 리스코프 치환 원칙

이 원칙은 한마디로 정리하면 “`서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다`”는 것으로 클라이언트가 “`차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다`”는 것이다.
    
### 클라이언트와 대체 가능성

> **대체 가능성을 결정하는 것은 클라이언트다.**
> 

리스코프 치환 원칙은 “**클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다**”는 아주 중요한 결론을 이끈다. 

즉, 상속 관계에 있는 **두 클래스 사이의 관계를 클라이언트와 떨어트려 놓고 판단하지 말라고 속삭**인다. 상속 관계는 클라이언트 관점에서 **자식 클래스가 부모 클래스를 대체할 수 있을 때만 올바르다.**

<br>

### is-a 관계 다시 살펴보기

- is-a 관계로 표현된 문장을 볼 때마다 **문장 앞에 “클라이언트 입장에서”라는 말이 빠져 있다고 생각하라.**
- is-a 관계는 객체지향에서 중요한 것은 **객체의 속성이 아닌 객체의** `행동`**이라는 점을 강조한다.**
- **상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계다.** 서브클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계라고 말할 수 없다.

<br>

### 타입 계층과 리스코프 치환 원칙

상속이 아닌 다른 방법을 이용하더라도 클라이언트의 관점에서 서로 다른 구성 요소를 동일하게 다뤄야 한다면 서브타이핑 관계의 제약을 고려해서 리스코프 치환 원칙을 준수해야 한다.

<br>
<br>

---

<br>

## 05 계약에 의한 설계와 서브타이핑

- `계약에 의한 설계`: **클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점**에서 표현하는 것
    - 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 `사전조건`과 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 `사후조건`, 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 `클래스 불변식`의 **세 가지 요소로 구성**된다.

- 리스코프 치환 원칙과 계약에 의한 설계 사이의 관계를 다음과 같은 한 문장으로 요약할 수 있다.
    
    > 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 ‘계약’을 준수해야 한다.
    > 

<br>

### 서브타입과 계약

- 어떤 타입이 슈퍼타입에 정의한 사전조건보다 더 약한 사전조건을 정의하고 있다면 그 타입은 서브타입이 될 수 있지만 더 강한 사전조건을 정의한다면 서브타입이 될 수 없다.
- 어떤 타입이 슈퍼타입에서 정의한 사후조건보다 더 강한 사후조건을 정의하더라도 그 타입은 여전히 서브타입이지만 더 약한 사후조건을 정의한다면 서브타입의 조건이 깨지고 만다.
