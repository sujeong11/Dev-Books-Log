## 01 디자인 패턴과 설계 재사용

- `디자인 패턴`: 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법
    - 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음
    - 설계 재사용을 위한 것
- `프레임워크`: 어플리케이션의 아키텍처를 구현 코드의 형태로 제공
    - 설계와 코드를 함께 재사용하기 위한 것

이 둘은 모두 **일관성 있는 협력**과 관련이 있다. `디자인 패턴`은 **특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공**한다. `프레임워크`는 **특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공**한다.

<br>

### 소프트웨어 패턴

패턴은 경험의 산물이다. 책상 위에서 탄생한 이론이나 원리와 달리 패턴은 치열한 실무 현장의 역학관계 속에서 검증되고 입증된 자산이다. 따라서 실무 경험이 적은 초보자라고 하더라도 패턴을 익히고 반복적으로 적용하는 과정 속에서 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있게 된다.

- 소프트웨어 개발과 직접적인 연관성을 가진 분석, 설계, 구현 영역만이 아닌 다양한 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추구하는 방법과 같이 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이 될 수 있다.
- 패턴은 홀로 존재하지 않는다. 특정 패턴 내에 포함된 컴포넌트와 컴포넌트 간의 관계는 더 작은 패턴에 의해 서술될 수 있다.
    - `패턴 언어`: 연관된 패턴들의 집합들이 모여 하나의 패턴 언어를 구성한다.
    - `패턴 시스템`: 패턴 언어 용어가 지닌 제약 조건을 완화하기 위한 것으로 두 용어가 거의 동일하게 사용되고 있다.

<br>

### 패턴 분류

- 가장 일반적은 방법으로 패턴의 범위나 적용에 따라 다음과 같이 분류한다.
    - `아키텍처 패턴`: 소프트웨어의 전체적인 구조를 결정하기 위해 사용
    - `분석 패턴`: 업무 모델링 시에 발견되는 공통적인 구조를 표하는 개념들의 집합 (도메인 내의 개념적인 문제를 해결하는데 초점)
    - `디자인 패턴`: 협력하는 컴포넌트 사이에 반복적으로 발생하는 구조를 서술
        - **중간 규모의 패턴**으로 특정한 설계 문제를 해결하는 것을 목적으로 한다.
    - `이디엄`: 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴

<br>

### 패턴과 책임-주도 설계

> 책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재사용성 등의 다양한 요소들의 트레이오프를 통해 결정된다.
> 
- `패턴`은 **반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 휼륭한 예제를 제공**
    - `STRATEGY 패턴`: 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공
    - `BRIDGE 패턴`: 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 커다란 집합으로 분해함으로써 설계를 확장 가능하게 만든다.
    - `OBSERVER 패턴`: 유연한 통지 메커니즘을 구축하기 위해 객체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공
- 중요한 것은 **패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실**이다.
- **굳이 책임 주도 설계의 절차를 하나하나 따르지 않고도** 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르게 구성할 수 있다.

💡 패턴의 구성 요소는 클래스가 아니라 ‘`역할`’이다.

<br>

### 캡슐화와 디자인 패턴

- `STRATEGY 패턴`: 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 `합성`을 이용
    - **추상 클래스 / 인터페이스**를 사용해 변경을 캡슐화
    - 결합도가 낮음
- `TEMPLATE METHOD 패턴`: 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 `상속`을 이용
    - **추상 메서드**를 사용해 변경을 캡슐화
    - 결합도 높음, 복잡도 낮음
- `DECORATOR 패턴`: 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로 객체의 행동을 결합하기 위해 객체 `합성` 사용
    - **선택적인 행동의 개수와 순서에 대한 변경**을 캡슐화

<br>

### 패턴은 출발점이다

패턴은 설계의 목표가 돼서는 안된다. **패턴은 단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반에 불과**하다. 디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그래도 따르지 말고 **목적에 맞게 패턴을 수정**하라.

<br>
<br>

---

<br>

## 02 프레임워크와 코드 재사용

### 코드 재사용 대 설계 재사용

> 재사용 관점에서 설계 재사용 보다 더 좋은 방법은 코드 재사용이다.
> 
- **코드 재사용**
    - 다양한 도메인에 재사용한 컴포넌트라는 개념은 비현실적이다. (가장 기본이 되는 아주 적은 부분만이 일반화될 수 있기 때문)
    - 즉, **가장 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것**이다. → 프레임워크
- **설계 재사용**
    - `구조적인 측면`: **추상 클래스나 인터페이스를 정의**하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계
    - `코드와 설계의 재사용`: 애플리케이션 개발자가 현재의 요구 사항에 맞게 커스터마이징할 수 있는 **애플리케이션의 골격**

<br>

### 상위 정책과 하위 정책으로 패키지 분리하기

- 프레임워크의 핵심은 추상 클래스나 인터페이스와 같은 추상화이다.
- **추상 클래스와 인터페이스가 일관성 있는 협력을 만드는 핵심 재료하는 것을 기억하자.**
    - 추상화를 이용해 변경을 캡슐화해야 한다.
    - 협력을 구현하는 **코드 안의 의존성은 가급적이면 추상 클래스나 인터페이스와 같은 추상화를 향하도록 작성해야 한다.**

상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경된다. 즉, 변하는 부분과 변하지 않는 부분을 분리해야 한다.

- 변하지 않는 것은 상위 정책에 속하는 역할들의 협력 구조
- 변하는 것은 구체적인 세부 사항

프레임워크는 여러 애플리케이션에 걸쳐 재사용 가능해야 하기 때문에 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 별도의 ‘배포 단위’로 분리해야 한다.

- 이를 위한 첫 걸음은 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리하는 것이다.
- 이러면 상위 정책을 구현하고 있는 패키지를 다른 애플리케이션에서 재사용할 수 있다.
    - 이는 `컨텍스트 독립성의 패키지 버전`

<br>

### 제어 역전 원리

상위 정책을 재사용한다는 것 → 도메인에 존재하는 핵심 개념들 사이의 협력 관계를 재사용한다는 것을 의미

> 객체지향 설계의 재사용성은 개별 클래스가 아니라 객체들 사이의 공통적인 협력 흐름으로부터 나온다.
> 
- 로버트 마틴은 휼륭한 객체지향 설계는 의존성이 역전된 설계라는 점을 강조한다.
- **의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘**이다.
    - 의존성 역전은 의존성의 방향뿐만 아니라 제어 흐름의 주체 역시 역전시킨다.
    - 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출한다.
