## 01 다형성

- `다형성`: 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 댛 서로 다른 구현을 연결할 수 있는 능력

- `오버로딩 다형성`: 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우

- `강제 다형성`: 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식

  (단, 오버로딩과 강제 다형성을 함께 사용하면 어떤 메서드가 호출될 지 모호해질 수 있다.)

- `매개변수 다형성`: 제네릭 프로그래밍과 관련이 높은데 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식

- `포함(서브타입) 다형성`: 메시지가 동일하더라도 수신한 객체에 따라 실제로 수행되는 행동이 달라지는 능력

  (포함 다형성은 객체지향 프로그래밍에서 가장 널리 알려진 형태의 다형성으로 특별한 언급이 없다면 다형성이라고 할 때는 포함 다형성을 의미하는 것이 일반적이다.)

포함 다형성을 구현하는 일반적인 방법은 상속을 사용하는 것이다. 즉, **상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것**이다.

<br>
<br>

---

<br>

## 02 상속의 양면성

**데이터와 행동을 객체라는 하나의 실행 단위 안으로 통합하는 것**은 객체지향 패러다임의 근간을 이루는 아이디어이다. 따라서 객체지향 프로그램을 작성하기 위해서는 항상 데이터와 행동이라는 두 가지 관점을 함께 고려해야 한다. 상속도 예외는 아니다. 

- `데이터 관점의 상속`: 부모 클래스의 모든 데이터를 자식 클래스 인스턴스에 자동으로 포함 가능
- `행동 관점의 상속`: 부모 클래스에 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함 가능

하지만 이 관점은 상속을 오해한 것이다. 상속의 목적은 **코드 재사용이 아니다.** 상속은 **프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 `타입 계층`을 구축하기 위한 것**이다. 

<br>

### 데이터 관점의 상속

자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것을 의미한다.

<br>

### 행동 관점의 상속

부모 클래스가 정의한 일부(퍼블릭) 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미한다.

[ 방법 ] 런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색하기 때문이다.

<br>
<br>

---

<br>

## 03 업캐스팅과 동적 바인딩

### 같은 메시지, 다른 메서드

`업캐스팅`: **부모 클래스 타입으로 선언된 변수**에 **자식 클래스의 인스턴스를 할당하는 것이 가능**하다.

`동적 바인딩`: 선언된 변수의 타입이 아니라 **메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정**된다. 이것은 객체지향 시스템이 메시지를 처리할 **메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문에 가능**하다.

이 둘을 통해 **동일한 수신자에게 동일한 메시지를 전송하는 동일한 코드를 이용해 서로 다른 메서드를 실행 가능**하다.

<br>
<br>

---

<br>

## 04 동적 메서드 탐색과 다형성

동적 메서드 탐색은 두 가지 원리로 구성된다.
1. `자동적인 메시지 위임`: **자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 상속 계층을 따라 부모 클래스에게 처리를 위임**한다.
2. `동적인 문맥`: **메시지를 수신했을 때 실제로 어떤 메서드를 실행할지 결정하는 것은 컴파일 시점이 아닌 실행 시점에 이뤄지며**, 메서드 탐색하는 경로는 self 참조를 이용해 결정한다.

이로 인해 메시지가 처리되는 문맥을 이해하기 위해서는 정적인 코드를 분석하는 것만으로는 충분하지 않다. 런타임에 실제로 메시지를 수신한 객체가 어떤 타입인지를 추적해야 한다.

<br>

### 자동적인 메시지 위임

적절한 메서드를 찾을 때 까지 상속 계층을 따라 부모 클래스로 처리가 `자동으로` 위임된다. (자식 클래스가 더 우선권을 가짐)

⇒ 이 관점에서 상속 계층을 정의하는 것은 메서드 탐색 경로를 정의하는 것과 동일하다.

<br>

### 동적인 문맥

메세드 전송 코드만으로는 어떤 클래스의 어떤 메서드가 실행되는지 알 수 없다. 중요한 것은 메시지를 **수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀐다**는 것이다. 그리고 **이 문맥을 결정하는 것은 바로 메시지를 수신한 객체를 가리키는** `self 참조`다.

- `self 전송`: 자신에게 다시 **메시지를 전송하는 것**

```java
public class Lecture {
	public String stats() {
		return String.format("Title: %s, Evaluation: %s", title, getEvaluationMethod());
	}
	
	public String getEvaluationMethod() {
		return "Pass or Fail";
	}
}
```

자신의 getEvaluationMethod **메서드를 호출한다는 표현은 정확하지 않다.** 현재 객체**(self 참조가 가리키는객체)**에게 getEvaluationMethod 메시지를 전송하는 것이다. 즉, **현재 객체에게 메시지를 전송하는 것**이다.

⇒ **Lecture 클래스의 getEvaluationMethod  메서드를 실행시키라는 의미가 아니라 self가 참조하는 현재 객체에 getEvaluationMethod  메세지를 전송하라는 의미**이다.

<br>

### 이해할 수 없는 메시지

상속 계층의 정상에 오고 나서야 자신이 메시지를 처리할 수 없다는 사실을 알게 되었다면? 이해할 수 없는 메시지를 처리하는 방법은 프로그래밍 언어가 `정적 타입 언어`에 속하는지, `동적 타입 언어`**에 속하는지에 따라 달라진다.**

- 정적 타입 언어

  코드를 컴파일할 때 메시지를 이해할 수 있는지 여부를 판단해 컴파일 에러를 발생시킨다.

- 동적 타입 언어

  최상위 클래스까지 메서드를 탐색한 후에 메서드를 처리할 수 없다는 사실을 발견하면 **self 참조가 가리키는 현재 객체에게 메시지를 이해할 수 없다는 메시지를 전송**한다.

이 외에도 desNotUnderstand나 method_missing 메시지에 응답할 수 있는 메서드를 구현해 이해 할 수 없는 메시지를 처리할 수 있는 능력을 가짐으로써 **메시지가 선언된 인터페이스와 메서드가 정의된 구현을 분리**할 수 있다.

<br>

### self 대 super

- `self 참조의 가장 큰 특징`: 동적이라는 점, 메시지를 수신한 객체의 클래스에 따라 메서드 탐색을 위한 문맥을 실행 시점에 결정한다.
- super 참조
    - **자식 클래스에서 부모 클래스의 인스턴스 변수나 메서드에 접근하기 위해 사용**
    - 용도는 부모 클래스에 정의된 메서드들 실행하기 위한 것이 아니다. 정확한 의도는 **‘지금 이 클래스의 부모 클래스에서부터 메서드 탐색할게요’**다. 즉, 반드시 부모 클래스에 위치하지 않아도 되는 유연성을 제공한다. **조상 클래스 어딘가에 있기만 하면 된다.**
    - 메서드를 탐색을 시작할 클래스를 **컴파일 시점에 미리 결정**해 놓을 수 있다.
      
<br>
<br>

---

<br>

## 05 상속 대 위임

자식 클래스에서 부모 클래스로 **self 참조를 전달하는 메커니즘**으로 상속을 바라보자.

### 위임과 self 참조

> **모든 객체지향 언어는 자동으로 self 참조를 생성하고 할당하기 때문에 메서드의 첫 번째 파라미터로 this를 받을 필요가 없다는 사실을 명심하라.**
> 

- **위임이 객체 사이의 동적인 연결 관계를 이용해 상속을 구현하는 방법**
  
- **상속이 매력적인 이유는 우리가 직접 구현해야 하는 이런 번잡한 과정을 자동으로 처리해 준다는 점이다. 부모-자식 인스턴스들 사이에 self 참조가 자동으로 전달된다.** 

- **이 self 참조의 전달은 결과적으로 자식 클래스의 인스턴스와 부모 클래스의 인스턴스 사이에 동일한 실행 문맥을 공유할 수 있게 해준다.**
