## Intro

- `협력`: 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용

- `책임`: 객체가 협력에 참여하기 위해 수행하는 로직

- 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 `역할`을 구성한다.

<br>
<br>

## 01 협력

협력은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법이다. 두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다.

- `메시지 전송`: 객체 사이의 협력을 위해 사용할 수 있는 커뮤니케이션 수단 (객체는 **다른 객체의 상세한 내부 구현에는 직접 접근할 수 없기** 때문에 이를 통해 자신의 요청을 전달한다.)
- 메시지를 수신한 객체가 **받은 메시지를 어떻게 처리할 지** `직접 결정`(**외부 객체는 메시지만 전송할 뿐** 메시지를 어떻게 처리될지는 알지 못함)한다. 이것은 객체가 자신의 일을 스스로 처리할 수 있는 `자율적인 존재`하는 것을 의미한다.
    - 즉, **객체를 자율적으로 만드는 가장 기본적인 방법**은 내부 구현을 `캡슐화`하는 것

<br>

### 협력이 설계를 위한 문맥을 결정한다

> 어떤 객체도 섬이 아니다.
> 

애플리케이션 안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다. **해당 객체가 어떤 협력에 참여하고 있기 때문**이다. ⇒ **협력은 객체가 필요한 이유와 객체가 수행하는 행동의 동기를 제공**한다. 

즉, `협력이라는 문맥을 고려하지 않고 객체의 행동을 결정하는 것은 아무런 의미가 없다.` 따라서 협력은 **객체를 설계하는데 필요한 일종의** `문맥`**을 제공**한다.

<br>
<br>

---

<br>

## 02 책임

> 협력에 참여하기 위해 객체가 수행하는 행동
> 

객체의 책임은 ‘`무엇을 알고 있는가`’와 ‘`무엇을 할 수 있는가`’로 구성된다. 

1. 객체는 자신이 맡은 책임을 수행하는데 필요한 정보를 알고 있을 책임이 있다. 
2. 객체는 자신이 할 수 없는 작업을 도와줄 객체를 알고 있을 책임이 있다.

책임은 객체지향 설계의 핵심이다. 크레이그 라만은 “**객체지향 개발에서 가장 중요한 능력은 책임을 능숙하고 소프트웨어 객체에 할당하는 것**”이라고 했다.

<br>

### 책임할당

[ 자율적인 객체를 만드는 가장 기본적인 방법 ]

- `정보 전문가 패턴`: 책임을 수행하는데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것

객체에게 책임을 할당하기 위해서는 다음과 같은 과정을 반복한다.

1. 우선 협력이라는 문맥을 정의해야 한다. (시스템이 담당할 하나의 책임)
2. 이를 객체에게 할당한다.
3. 더 작은 책임이 있다면 이를 여러 객체들에게 할당한다.

> 책임 할당 과정이 위 과정처럼 단순하지 만은 않다. 때로는 **응집도와 결합도의 관점**에서 **정보 전문가가 아닌 다른 객체에게 책임을 할당하는 것이 더 적절한 경우**가 있다.
> 

<br>

### 책임 주도 설계

: 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법

이 설계 방법은 객체의 구현이 아닌 `책임에 집중`할 수 있게 한다. (책임이 유연하고 견고한 객체지향 시스템을 위해 가장 중요한 재료이기 때문)

<br>

### 메시지가 객체를 결정한다

객체가 메시지를 선택하는 것이 아니라 **메시지가 객체를 선택해야 하는 두 가지 중요한 이유**가 있다.

[1] 객체가 최소한의 인터페이스를 가질 수 있게 된다.
    
> 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문
> 
[2] 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.
    
> 객체의 인터페이스는 무엇을 하는지 표현해야 하지만 어떻게 수행하는지는 노출해서는 안되기 때문
> 

<br>

### 행동이 상태를 결정한다

객체의 행동은 객체가 협력에 참여할 수 있는 유일한 방법이다. **객체가 협력에 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동**이다. **상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일 뿐**이다.

**초보자들**은 **먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정**한다. 이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다.

<br>
<br>

---

<br>

## 03 역할
: 객체가 어떤 특정한 협력 안에서 수행하는 `책임의 집합`

### 유연하고 재사용 가능한 협력

만약 2개의 할인 정책이 있다고 할 때 이들은 모두 할인 요금 계산이라는 **동일한 책임을 수행**한다.  따라서 *객체라는 존재를 지우고 할인 요금을 계산하라*라는 메시지에 응답할 수 있는 대표자를 생각한다면 **두 협력을 하나로 통합할 수 있을 것**이다.

⇒ 불필요한 중복 코드 제거된다. 그리고 새로운 할인 정책을 추가하기 위해 새로운 협력을 추가할 필요가 없다.

> 이렇게 `책임과 역할을 중심으로 협력을 바라보는 것`이 바로 **변경과 확장이 용이한 유연한 설계로 나아가는 첫걸음**이다.

💡 **객체에게 중요한 것은 행동이며, 역할은 객체를 `추상화`해서 객체 자체가 아닌 협력에 초점을 맞출 수 있게 한다.**

<br>

### 객체 대 역할

협력에 적합한 책임을 수행하는 대상이 한 종류라면 간단하게 객체로 간주한다. 만약, 여러 종류의 객체들이 참여할 수 있다면 역할이라고 부르면 된다.

<br>

### 역할과 추상화

> 2장에서 추상화를 이용한 설계가 가진 두 가지 장점과 비슷하다.
> 

[ 장점 1 ] 동일한 협력을 수행하는 객체들을 추상화할 수 있다.

[ 장점 2 ] 기존 코드를 수정하지 않고도 새로운 행동을 추가할 수 있다.
