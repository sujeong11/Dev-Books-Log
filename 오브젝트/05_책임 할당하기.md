## 01 책임 주도 설계를 향해

### 데이터보다 행동을 먼저 결정하라

**“이 객체가 수행해야 하는 책임은 무엇인가”를 결정 후** “이 책임을 수행하는데 필요한 데이터는 무엇인가”를 결정하자.

<br>

### 협력이라는 문맥 안에서 책임을 결정하라

> 객체지향 설계에서 가장 중요한 것은 **적절한 객체에게 적절한 책임을 할당하는 능력**이다. 객체에게 할당된 **책임의 품질은 협력에 적합한 정도로 결정**된다.

협력에 적합한 책임을 수확하기 위해서는 객체를 결정한 후에 메시지를 선택하는 것이 아니라 메시를 결정한 후에 객체를 선택해야 한다. **메시지가 존재하기 때문에 그 메시지를 처리할 객체가 필요한 것**이므로 **메시지가 객체를 선택하게 해야 한다.**

**메시지가 클라이언트의 의도를 표현한다는 사실**과 **객체를 결정하기 전 객체가 수신할 메시지를 먼저 결정한다는 점에 주목**하라. 클라이언트는 단지 임의의 객체가 메시지를 수신할 것이라는 사실을 믿고 자신의 의도를 표현한 메시지를 전송할 뿐이고 메시지를 수신하기로 결정된 객체를 메시지를 처리할 `책임`을 할당 받게 된다.

⇒ 메시지 수신자에 대한 어떠한 가정도 할 수 없다. **메시지의 전송자 관점에서 메시지 수신자가 깔끔하게 `캡슐화`되는 것이다.**

<br>

### 책임 주도 설계

핵심은 **책임을 결정한 후 책임을 수행할 객체를 결정하는 것**이다. 그리고 협력에 참여하는 객체들의 책임이 어느 정도 정리될 때까지는 **객체의 내부 상태에 대해 관심을 가지지 않는다.**

<br>
<br>

---

<br>

## 02 책임 할당을 위한 GRASP 패턴

> General Responsibility Assignment Software Pattern: 객체에 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합
> 

### 도메인 개념에서 출발하기

어떤 책임을 할당해야 할 때 가장 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념이다.

<br>

### 정보 전문가에게 책임을 할당하라

> 애플리케이션이 제공해야 하는 기능을 책임으로 생각하자.
> 

[1] 메시지를 전송할 객체는 무엇을 원하는가?

[2] 메시지를 수신할 적합한 객체는 누구인가?

⇒ 이 질문을 위해서는 **객체가 상태와 행동을 통한 캡슐화의 단위라는 사실에 집중**해야 한다. 객체는 자신의 상태를 스스로 처리해야 하는 자율적인 존재로, **객체의 책임과 책임을 수행하는데 필요한 상태는 동일한 객체 안에 존재해야 한다.**

따라서, `책임을 할당하는 첫 번째 원칙`은 **책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것** (`정보 전문가 패턴`: INFORMATION EXPERT)이다. 단, 모든 정보를 알고 있을 필요는 없고 필요한 정보를 제공해줄 수 있는 다른 객체를 알고 있으면 됨.

<br>

### 높은 응집도와 낮은 결합도

> 설계는 트레이드오프 활동이라는 것을 기억하자. 우리는 여러 설계 중 한 가지를 선택해야 하는 경우가 빈번하다.
> 
- 책임과 협력의 품질을 검토하는데 사용할 수 있는 중요한 평가 기준

[1] `낮은 결합도(LOW COUPLING) 패턴`: 어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까?

⇒ 설계의 전체적인 결합도를 낮게 유지되도록 책임을 할당하라.

[2] `높은 응집도(HIGH COHESION) 패턴`: 어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가?

⇒ 높은 응집도를 유지할 수 있게 책임을 할당하라.

<br>

### 창조자에게 객체 생성 책임을 할당하라

`창조자(CREATOR) 패턴`: **어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에게 해당 객체를 생성할 책임을 맡기는 것**이다. 이로 인해 설계가 낮은 결합도를 유지할 수 있다.

<br>
<br>

---

<br>

## 04 책임 주도 설계의 대안

경험을 쌓은 숙련된 설계자조차도 적절한 책임과 객체를 선택하는 일에 어려움을 느낀다. 우선, 목적에 맞게 기능을 수행하도록 코드를 작성하고 나서 책임들을 올바른 위치로 이동시키는 것이 경험이 없는 개발자들에게 유용하다.

단, 코드를 수정 후 겉으로 드러나는 동작이 바뀌어서는 안된다. 캡슐화를 향상시키고, 결합도를 낮춰야 하지만 동작은 그대로 유지해야 한다. 이렇게 내부 구조만 변경하는 것을 `리팩터링`이라고 한다.

<br>

### 메서드 응집도

긴 메서드들은 응집도 낮기 때문에 이해하기도 어렵고 재사용하기도 어려우며 변경하기도 어렵다. 이런 메서드를 `몬스터 메서드`라고 부른다.

그러므로 **객체로 책임을 분배할 때 가장 먼저 할 일은 메서드를 응집도 있는 수준으로 분해하는 것**이다. 이러면 메서드들의 목적이 명확해지고 분명하기 때문에 재사용이 쉬우며 코드 가독성도 올라간다. 그리고 코드 수정에 용이하다.

<br>

### 객체를 자율적으로 만들자

- 어떤 메서드를 어떤 클래스로 이동시켜야 할까?

메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동시키면 된다. 이 때, 캡슐화 / 응집도 / 결합도의 측면에서 이동시킨 메서드의 적절성을 판단해야 한다.
