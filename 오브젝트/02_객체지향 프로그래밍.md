## 02 객체지향 프로그래밍을 향해

### 협력, 객체, 클래스

💡 진정한 객체지향 패러다임으로의 전환은 **클래스가 아닌** `객체에 초점`**을 맞출 때에만 얻을 수 있다.**

1. 어떤 클래스가 필요한지를 고민하기 전에 **어떤 객체들이 필요한지 고민**하라.

2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 **협력하는 공동체의 일원**으로 봐야 한다.

> **휼륭한  협력이 휼륭한 객체를 낳고 휼륭한 객체가 휼륭한 클래스를 낳는다.**
>

<br>

### 자율적인 객체

> 많은 사람들은 객체를 상태와 행동을 함께 포함하는 식별 가능한 단위로 정의한다.

💡 **일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야 한다.**

⇒ 클래스의 속성은 private으로 선언해 감추고 외부에 제공해야 하는 일부 메서드만 public으로 선언해야 한다.

이렇게 **객체의 외부와 내부를 구분**해 변경될 가능성이 있는 세부적인 구현 내용을 private 영역 안에 감춤으로써 `변경으로 인한 혼란을 최소화`할 수 있다.

<br>

### 협력하는 객체들의 공동체

> 협력: 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용
> 

객체가 다른 객체와 상호 작용할 수 있는 유일한 방법은 `메시지를 전송`하는 것 뿐이다. 다른 객체에게 요청이 도착할 때 해당 객체가 `메시지를 수신`했다고 이야기 한다. 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정함

이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 `메서드`라고 부른다.

<br>
<br>

---

<br>

## 04 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성

💡 유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 **코드의 의존성과 실행 시점의 의존성이 다르다는 것**이다.

[ 간과해서는 안되는 점 ]

코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다는 것이다. 하지만 코드는 더 유연해지고 확장 가능해진다. ⇒ 이와 같은 의존성의 양면성은 `트레이오프`를 가진다.

> **설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다**는 사실을 기억하라. 반면 **유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다**는 사실도 기억하라.
> 

⇒ 항상 유연성과 가독성 사이에 고민해야 한다. 무조건 유연한 설계도 무조건 읽기 쉬운 코드도 정답이 아니다. 이것이 객체지향 설계가 어려우면서도 매력적인 이유다.

<br>

### 인터페이스와 다형성

클래스 간 구현을 공유할 필요가 없다면 인터페이스 사용하자. 상속과 비슷하게 동일한 인터페이스를 구현하며 `다형적 협력에 참여`할 수 있다.

<br>
<br>

---

<br>

## 05 추상화와 유연성

### 추상화의 힘

[ 장점 1 ] 추상화 계층만 따로 떼어 높고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.
    
> 세부 사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있게 한다.
> ex) 어떤 할인 정책이 있는지는 중요하지 않고 할인 정책이 존재한다는 것만으로도 충분한 경우가 있다.
> 
[ 장점 2 ] 추상화를 이용하면 설계가 좀 더 유연해진다.
    
> 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.
> 

<br>

### 유연한 설계

할인 정책을 적용하지 않을 때 if 문으로 할인 정책이 없을 경우를 확인하는 것보다는 **0원이라는 할인 요금을 계산할 책임을 그대로 DiscountPlicy 계층에 유지**시키는 것이 좋다.

=> `추상화를 중심으로 코드의 구조를 설계`하면 **유연하고 확장 가능한 설계를 만들 수 있다는 것**이다. (설계가 구체적인 상황에 결합되는 것을 방지하기 때문)

<br>

### 코드 재사용

> 코드 재사용을 위해서는 상속보다 합성이 더 좋은 방법이라는 이야기를 많이 들었을 것이다. 

`합성`: 다른 객체의 인스턴스를 **자신의 인스턴스 변수로 포함**해서 재사용하는 방법

<br>

### 상속

[ 단점 1 ] 캡슐화 위반
    
> 상속을 사용하기 위해서는 부모 클래스 내부 구조를 잘 알고 있어야 해 부모 클래스의 구현이 자식 클래스에게 노출된다.
> 

> 캡슐화의 약화로 자식 클래스가 부모 클래스에게 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률이 높다.
> 
[ 단점 2 ] 설계를 유연하지 못하게 만든다.
    
> 부모 클래스와 자식 클래스가 강하게 결합되어 있어 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.
> 

<br>

### 합성

> 합성은 상속이 가지는 두 가지 문제점을 모두 해결한다.
> 
1. 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.
2. 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.

💡 상속은 클래스를 통해 강하게 결합되는데 비해 **합성은 메시지를 통해 느슨하게 결합**된다.

⇒ 코드 재사용을 위해서는 `상속보다는 합성을 선호하는 것이 더 좋은 방법`이다.
