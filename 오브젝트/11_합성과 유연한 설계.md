## 01 상속을 합성으로 변경하기

> 이 둘은 코드 재사용이라는 공통점 이외에 모든 면에서 차이가 있다.
> 
- `상속`: 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용
    - 부모 클래스와 자식 클래스의 **의존성은 컴파일타임에 해결**
    - 부모 클래스 내부 구현에 대해 자세히 알아야 하기 때문에 결합도가 높다.
    - **is-a 관계**
- `합성`: 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용
    - 두 객체 사이의 **의존성은 런타임에 해결** -> 실행 시점에 동적으로 변경 가능
    - 합성은 구현이 아닌 퍼블릭 인터페이스에 의존해 변경에 더 안정적이다.
    - **has-a 관계**
      
[ 재사용 대상 ]

1. `상속`: **부모 클래스 안에 구현된 코드 자체**

2. `합성`: **포함되는 객체의 퍼블릭 인터페이스**

<br>

### 불필요한 인터페이스 상속 문제

1. **불필요한 인터페이스 상속 문제** - ex) Stack / Properties
2. **메서드 오버라이딩의 오작용 문제** - ex) InstrunmentedHashSet
3. **부모 클래스와 자식 클래스의 동시 수정 문제** - ex) PersonalPlaylist

> 합성을 사용하면 위 문제점들을 해결할 수 있다.
> 

<br>

### 상속을 합성으로 바꾸는 방법
💡 **자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.**

<br>
<br>

---

<br>

## 02 상속으로 인한 조합의 폭발적인 증가

### 훅 메서드

[ 문제 ] 부모 클래스에 추상 메서드를 추가하면 **모든 자식 클래스들이 이 추상 메서드를 오버라이딩 해야 한다.** 그리고 모든 추상 메서드의 구현이 동일하다.

⇒ **추상 메서드에 대해 기본 구현을 제공**해 반드시 오버라이딩을 할 필요가 없도록 만든다. 이런 메서드를 훅 메서드라고 한다.

<br>

### 중복 코드의 덫에 걸리다

- `클래스 폭발` 또는 `조합의 폭발`: 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우
    - 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 **상속의 근본적인 한계 때문에 발생하는 문제**
    - **컴파일타임에 결정된** 자식 클래스와 부모 클래스 사이의 **관계는 변경될 수 없다.**
    - 그러므로 **다양한 조합이 필요한 상황의 유일한 해결 방법은 새로운 클래스를 추가하는 것 뿐**
    - 이는 수정할 때도 문제가 된다. → 동일한 많은 코드를 수정해야 할 수 있다.

<br>
<br>

---

<br>

## 03 합성 관계로 변경하기

> 8장: 컴파일 의존성과 런타임 의존성의 거리가 멀수록 설계가 유연해진다.
> 

- 합성을 사용하면 구현이 아닌 퍼블릭 인터페이스에 대해서만 의존할 수 있기 때문에 런타임에 객체 관계를 변경 가능

- [ 큰 장점 ] **컴파일 의존성에 속박되지 않고 다양한 방식의 런타임 의존성을 구성할 수 있다는 것**

단, 컴파일 의존성과 런타임 의존성의 거리가 멀수록 설계가 복잡해 코드를 이해하기 어려워진다. 설계는 **트레이드오프의 산물**이다. **대부분의 경우에는 단순한 설계가 정답이지만, 변경에 따른 고통이 복잡성으로 인한 혼란을 넘어서고 있다면 유연성의 손을 들어주는 것이 현명한 판단일 확률이 높다.**

<br>

### 새로운 정책 추가하기

💡 요구사항이 변해 새로운 기능을 추가해야 할 때, **오직 하나의 클래스만 추가**하면 된다.

💡 요구사항이 변해 기존 기능을 수정해야 할 때, **오직 하나의 클래스만 수정**하면 된다.

⇒ 이는 `단일 책임 원칙`을 준수하고 있는 것으로 이것이 `합성의 진가`다.

<br>

### 객체 합성이 클래스 상속보다 더 좋은 방법이다

- 상속은 사용해서는 안 되는 것인가? 상속을 사용해야 하는 경우는 언제인가?

먼저, 상속을 `구현 상속`과 `인터페이스 상속`의 두 가지로 나눠야 한다. 이번 장은 구현 상속으로 발생하는 문제들에 대해 알아봤고 13장에 인터페이스 상속에 대해 배우고 **구현 상속을 피하고 인터페이스 상속을 사용**해야 하는 이유를 알게 될 것이다.
