## 01 상속과 중복 코드

중복 코드는 변경을 방해한다. 이것이 중복 코드를 제거해야 하는 가장 큰 이유다.

### DRY 원칙

> Don’t Repeat Yourself로 동일한 지식을 중복하지 말라는 것
> 

모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다.

<br>

### 중복과 변경
    
- 한 달에 한 번씩 가입자별로 전화 요금을 계산하는 애플리케이션을 개발해보자
    - (코드는 p.310 참고 - Phone / Call 클래스)
- 만약, 애플리케이션 출시 후 ‘심야 할인 요금제’라는 새로운 요금 방식을 추가해야 한다면?
    - 가장 간단한 방법은 Phone의 코드를 복사해 새로운 클래스를 만든 후 수정하는 것
    - 하지만 중복 코드가 존재하기 때문에 언제 터질지 모르는 시한폭탄을 안고 있는 것과 같다.

많은 코드 더미 속에서 어떤 코드가 중복인지 파악하는 것은 쉬운 일이 아니다.  모든 중복 코드를 한 번에 잘 수정했다고 해도 더 큰 문제는 서로 다르게 수정할 수도 있다는 점이다.

⇒ **중복 코드는 새로운 중복 코드를 부른다. 즉, 버그에 취약해지고 코드 변경 속도가 느려진다.**

> **기회가 생길 때마다 코드를 DRY하게 만들기 위해 노력하라.**
> 
- `타입 코드` 사용하기

두 클래스 사이의 중복 코드를 제거하는 한 가지 방법은 **클래스를 하나로 합치는 것**이다. 위 예시의 두 클래스는 요금제를 구분하는 타입 코드를 추가해 **로직을 분기**시키면 클래스 하나에 모을 수 있다.

> 객체지향 프로그래밍 언어는 타입 코드를 사용하지 않고 중복 고드를 관리할 수 있는 방법을 제공한다. - `상속`

<br>

### 상속을 이용해서 중복 코드 제거하기
    
- 상속을 염두에 두고 설계되지 않은 클래스를 상속으로 재사용하는 것은 생각처럼 쉽지 않다.
- 상속은 결합도를 높인다.
- 부모 클래스와 자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다.

<br>

### 강하게 결합된 Phone과 NightlyDiscountPhone
    
💡 **[ 상속을 위한 경고 ]**

자식 클래스의 메서드 안에서 `super` 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. **super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.**

<br>
<br>

---

<br>

## 02 취약한 기반 클래스 문제

**부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상**을 의미한다. 이는 `캡슐화를 약화`시키고 `결합도를 높인다.` 이는 객체지향이 가진 강력함을 반감시킨다.

<br>

### 불필요한 인터페이스 상속 문제

상속을 받으면 **자식 클래스의 퍼블릭 인터페이스에 부모 클래스의 퍼블릭 인터페이스가 합쳐진다.**

- 예시 1: Vector를 상속받은 Stack
    - 임의의 위치에 요소를 조회 / 추가/ 삭제 가능한 부모 클래스의 퍼블릭 인터페이스 때문에
    - 맨 마지막에만 요소를 추가/제거하는 Stack의 규칙을 쉽게 위반할 수 있다.
- 예시 2: Hashtable을 상속받은 Properties
    - 제너릭 도입 전에 만들어진 Hashtable는 컴파일러가 String인지 여부를 체크할 수 있는 방법이 없어 Hashtable의 put 메서드를 이용하면
    - 키와 값 타입으로 String만 가질 수 있는 Properties에 다양한 타입의 키와 값을 저장 가능함

💡 **[ 상속을 위한 경고 2 ]**

**상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.**

<br>

### 메서드 오버라이딩의 오작용 문제

- 예시: HashSet의 구현에 강하게 결합된 InstrumentedHashSet (자식 클래스)
    - 요소의 크기를 구할 때 자식 / 부모 클래스 메서드가 모두 호출되어 크기가 2배가 나올 수 있다.
      
💡 **[ 상속을 위한 경고 3 ]**

**자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.**

[ 주의할 점 ]

`조슈아 블로치` →  클래스가 상속되기를 원한다면 `상속을 위해 클래스를 설계하고 문서화`해야 하며, 그렇지 않은 경우에는 상속을 금지시켜야 한다고 주장
  - 객체지향의 핵심이 구현을 캡슐화하는 것인데 이렇게 내부 구현을 공개하고 문서화하는 것이 옳은 것인가?
  - 이것은 결국 상속이 캡슐화를 위반함으로써 초래된 불행인 것이다.
  - 즉, 설계는 트레이드오프 활동이다. 상속은 코드 재사용을 위해 캡슐화를 희생한다.

<br>

### 부모 클래스와 자식 클래스의 동시 수정 문제

상속은 기본적으로 부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에 자식 클래스가 부모 클래스의 내부에 대해 속속들이 알도록 강요한다. 따라서 코드 재사용을 위한 상속은 부모 클래스와 자식 클래스를 강하게 결합시키기 때문에 함께 수정해야 하는 상황 역시 빈번하게 발생할 수 밖에 없는 것이다.

- `조슈아 블로치`의 조언

서브 클래스는 올바른 기능을 위해 슈퍼클래스의 세부적인 구현에 의존한다. 슈퍼 클래스의 작성자가 확장될 목적으로 특별히 그 클래스를 설계하지 않았다면 서브클래스는 슈퍼 클래스와 보조를 맞춰 진화해야 한다.

💡 **[ 상속을 위한 경고 4 ]**

**클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.**

<br>
<br>

---

<br>

## 04 차이에 의한 프로그래밍

기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 `차이에 의한 프로그래밍`이라 한다.

상속을 사용하면 이미 존재하는 클래스의 코드를 기반으로 다른 부분을 구현함으로써 새로운 기능을 쉽고 빠르게 추가할 수 있다. 하지만, 코드를 재사용하기 위해 맹목적으로 상속을 사용하는 것은 위험하다. `상속`이 코드 `재사용이라는 측면`에서는 `매우 강력한 도구`인 것은 사실이지만 **강력한 만큼 잘못 사용할 경우 돌아오는 피해 역시 크다.**

⇒ `상속의 오용과 남용`은 **애플리케이션을 이해하고 확장하기 어렵게 만든다. 정말로 필요한 경우에만 상속을 사용하라.**
