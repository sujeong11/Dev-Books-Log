## 34강 인덱스와 B-tree

인덱스는 구조에 따라 다음과 같이 분류
- `B-tree`
- `비트맵 인덱스`
- `해시 인덱스`

<br>

### [1] 만능형 : B-tree

- **데이터를 트리 구조로 저장하는 형태의 인덱스 (가장 많이 사용)**
- **검색 알고리즘**으로서는 **뛰어나게 성능이 좋은 편이 아니다.**
    - 그럼에도 여전히 사용되는 이유는 **균형이 잘 잡혀있기 때문**
- 사실, 대부분의 DB에서는 **트리의 리프 노드에만 기값을 저장**하는 `B+tree`라는, B-tree의 수정 버전을 채택한다.
    - 하지만 본질적인 특징은 둘이 다르지 않다.
    - `B+tree`의 특징: 트리의 깊이가 3-4 정도의 수준으로 일정 / 데이터가 정렬 상태를 유지

<br>

### [2] 기타 인덱스

- 비트맵 인덱스: 데이터를 비트 플래그로 변환해서 저장
    - 갱신할 때의 오버헤드가 너무 커 빈번한 갱신이 일어나지 않는 BI/DWH 용도로 사용
- 해시 인덱스: 거의 사용 X

<br>
<br>
<br>

---

<br>

## 35강 인덱스를 잘 활용하려면

인덱슬르 잘 활용하려면 몇 가지 포인트를 고려해야 한다.

### [1] 카티널리티와 선택률

- **인덱스는 테이블의 특정 필드집합에 대해 만든다.**
- 이때 어떤 필드에 대해 인덱스를 작성할 것인지 기준이 되는 요소가 필드의 카디널리티와 선택률이다.
    - `카디널리티`: 값의 균형을 나타내는 개념
        - 모든 레코드에 다른 값이 들어가 있는 필드가 카디널리티가 가장 높다.
    - `선택률`:  특정 필드 값을 지정했을 때 몇 개의 레코드가 선택되는지 나타내는 개념
        - 100개의 레코드를 가진 테ㅣ블에서 유일키로 한 개의 레코드가 선택된다면
        - 1 / 100 = 0.01

<br>

### [2] 인덱스를 사용하는 것이 좋은지 판단하려면

1. `카디널리티가 높을 것`
2. `선택률이 낮을 것`
- 대체로 5 ~ 10% 이하가 기준
- **선택률이 10%보다 높다면 테이블 풀 스캔을 하는 편이 더 빠르다.**

<br>
<br>
<br>

---

<br>
<br>

## 36강 인덱스로 성능 향상이 어려운 경우

- 대규모 데이터베이스일수록 인덱스 설계도 굉장히 중요해진다.
- **인덱스 설계란, 테이블 정의와 SQL만 봐서 할 수 있는 작업이 아니다.**
    - 특정 SQL에 적절한 인덱스를 작성하려면, **SQL의 검색 조건과 결합 조건을 바탕으로 데이터를 효율적으로 압축할 수 있는 조건을 찾아야 한다.**
    - **이를 위해 SQL 구문과 검색 키 필드의 `카디널리티`를 알아야 한다.**

<br>

### [1] 압축 조건이 존재하지 않음

```sql
SELECT order_id, receive_date FROM Orders;
```

- 위는 매우 **간단한 SELECT 구문**으로 실행 계획은 **데이터 풀 스캔**일 것이다.
- **WHERE 구가 애시당초 없으므로 인덱스로 작성할만한 필드로 존재하지 않는다.**

(단, 이런 경우는 실무에서 거의 없다.) 

<br>

### [2] 레코드를 제대로 압축하지 못하는 경우

```sql
-- 압축 조건이 있지만 레코드를 제대로 압축하지 못하는 SQL 구문
SELECT order_id, receive_date
FROM Orders
WHERE process_flag = '5';
```

- 만약, **WHERE 절로 인해 선택되는 레코드가 절반 이상**이라고 한다면 **인덱스를 사용한다고 하더라도 테이블 풀 스캔보다 더 느려질 수 있다.** 결국 `역효과만 발생`하는 것이다.
    - **이 필드는 인덱스로 만들기 적절하지 않은 것이다.**
- 즉, **인덱스가 제대로 작동하려면 어디까지나 ‘레코드를 크게 압축할 수 있는 검색 조건’이 있어야 한다.**

<br>

### [3] 인덱스를 사용하지 않는 검색 조건

- `중간 일치, 후방 일치의 LIKE 연산자`
    
    ```sql
    SELECT order_id
    FROM Orders
    WHERE shop_name LIKE '%대공원%';
    ```
    
    - `LIKE` 연산자를 사용하는 경우 인덱스는 **전방 일치(’%대공원’)에만 적용 가능**
    - **중간 일치 / 후방 일치에는 사용 불가능**
- `색인 필드로 연산하는 경우`
    
    ```sql
    SELECT *
    FROM SomeTable
    WHERE col_1 * 1.1 > 100;
    ```
    
    - 단, **검색 조건의 우변에 식을 사용할 때는 인덱스가 사용**된다.
    
    ```sql
    WHERE col_1 > 100 / 1.1;
    ```
    
- `IS NULL을 사용하는 경우`
    - **일반적으로 색인 필드의 데이터에 NULL이 존재하지 않기 때문**
    
    ```sql
    SELECT *
    FROM SomeTable
    WHERE col_1 IS NULL;
    ```
    
- `색인 필드에 함수를 사용하는 경우`
    - 색인 필드로 연산하는 경우와 같다.
    - **인덱스 내부에 존재하는 값은 어디까지만 col_1이지 LENGTH(col_1)이 아니기 때문**
    - 함수 색인하는 방법도 있지만, 쓸데없는 연산 비용이 발생하므로 기본적으로 사용하지 않는게 좋다.
    
    ```sql
    SELECT *
    FROM SomeTable
    WHERE LENGTH(col_1) = 10;
    ```
    
- `부정형을 사용하는 경우`
    - <>, !=, NOT IN
    
    ```sql
    SELECT *
    FROM SomeTable
    WHERE col_1 <> 100;
    ```
    
<br>
<br>
<br>

---

<br>
<br>

## 37강 인덱스를 사용할 수 없는 경우 대처법

1. **애플리케이션에서의 설정으로 처리**
2. **인덱스 온리 스캔**

<br>

### [1] 외부 설정으로 쿼리 - 깊고 어두운 강 건너기

- UI 설계로 처리
    - 예) ‘`점포 ID로 검색하면 반드시 주문일도 함께 입력`’해야 검색 버튼을 누를 수 있게 하는 등의 **입력 제한을 둔다면 ORders 테이블에 더 많은 압축을 가할 수 있다.**
    - ‘`기간 검색은 최대 1개월까지`’라는 조건을 준다면 **기간 검색에서도 인덱스를 잘 사용할 가능성이 커진다.**
    - 이것이 36강에서 인덱스는 테이블 정의와 SQL만 봐서 할 수 있는 작업이 아니라고 했던 이유이다.

<br>

### [2] 외부 설정을 사용한 대처 방법의 주의점

- 사용자란 아무런 필수조건 없이 내 마음대로 입력하는 것을 좋아한다.
- **성능과 사용성의 트레이드오프를 통해 타협점을 찾는 것**이, DB 엔지니어가 해야 하는 일이다.

<br>

### [3] 데이터 마트로 대처

- 외부 설정에 영향을 받지 않는 방법 중 하나가 바로 데이터 마트
- `데이터 마트`: **특정 쿼리(군)에서 필요한 데이터만을 저장하는, 상대적으로 작은 크기의 테이블**
    - 원래 테이블의 부분 집합 또는 서브넷이라고 보면 좋다.

```sql
CREATE TABLE OrderMart
(order_id CHAR(4) NOT NULL,
receive)date DATE NOT NULL);
```

```sql
SELECT order_id, receive_date
FROM OrderMart;
```

<br>

### [4] 데이터 마트를 채택할 시 주의점

- `데이터 신선도`
    - 특정한 시점마다 원본 테이블에서 데이터를 동기화해야 한다. (주로 야간)
    - **만약, 데이터 신선도가 중요한 경우라면 이러한 방법은 채택하기 어렵다.**
- `데이터 마트 크기`
    - 데이터 마트를 만드는 목적은 테이블의 크기를 작게해 I/O 양을 줄이는 것으로 원본 테이블에서 **크기를 딱히 줄일 수 없다면 데이터 마트를 만들어도 빨라지지 않는다.**
    - **SELECT * 처럼 모든 필드를 검색해야 하는 경우**나, **검색 조건의 선택률이 높아 레코드를 제대로 압축하지 못하는 경우**에는 데이터를 만들어도 **성능적인 개선이 불가능**하다.
        - 단, **GROUP BY 절을 미리 사용해서 집계를 마치고 데이터 마트를 만들면**, **필드 수와 레코드 수를 크게 줄일 수 있으며, GROUP BY에 필요한 정렬 또는 해시 처리도 사전에 끝낼 수 있으므로 굉장히 효과적**이다.
- `데이터 마트 수`
    - 더 이상 사용하지 않는데도 쓸데없이 동기화가 일어나는 ‘좀비 마트’가 생기거나 관리가 불가능해지는 경우가 있다.
    - 따라서 데이터 마트에 지나치게 의존하는 것은 좋지 않다.
- `배치 윈도우`

이처럼 데이터 마트는 간단한 성능 개선 방법처럼 보이지만, 실제로는 고려할 포인트가 많다.

<br>

### [5] 인덱스 온리 스캔으로 대처

```sql
SELECT order_id, receive_date
FROM Orders;
```

- 위 쿼리를 테이블을 풀 스캔이 아닌 `인덱스`로 바꿀 수 있다.

```sql
CREATE INDEX CoveringIndex ON Orders (order_id, receive_date); -- 커버링 인덱스
```

- `인덱스 온리 스캔`: **SQL 구문에서 필요한 필드를 인덱스만으로 커버할 수 있는 경우에 테이블 접근을 생략하는 기술**
- 장점
    - **데이터 마트를 사용할 때와 마찬가지로 I/O 비용을 줄일 수 있다.**
    - **인덱스는 테이블 필드의 부분 집합만 저장하므로 원래 테이블에 비해 크기가 굉장히 작다.**
    - **인덱스를 사용하는 경우 애플리케이션을 수정할 필요가 없다.**
- 이전에 봤던 SQL 구문에 `인덱스 온리 스캔`을 사용할 수 있다.
    
    ```sql
    -- 압축 조건이 있지만 레코드를 제대로 압축하지 못하는 SQL 구문
    SELECT order_id, receive_date
    FROM Orders
    WHERE process_flag = '5';
    ```
    
    ```sql
    CREATE INDEX CoveringIndex ON Orders (process_flag, order_id, receive_date);
    ```
    
    ```sql
    -- 인덱스를 사용하지 않는 LIKE 연산자 (중간, 후방)
    SELECT order_id
    FROM Orders
    WHERE shop_name LIKE '%대공원%';
    ```
    
    ```sql
    CREATE INDEX CoveringIndex ON Orders (shop_name, order_id, receive_date);
    ```

<br>

### [6] 인덱스 온리 스캔의 주의사항

- `DBMS에 따라 사용할 수 없는 경우도 있다.`
    - 오래된 버전에서는 지원하지 않을 수 있다.
- `한 개의 인덱스에 포함할 수 있는 필드 수에 제한이 있다.`
    - 인덱스의 크기는 무제한이 아니며 포함할 수 있는 필드 수 또는 크기에 제한이 있다.
    - 인덱스의 크기가 너무 커지면, 물리 I/O를 줄이겠다는 당초의 목적이 희미해진다.
- `갱신 오버 헤드가 커진다.`
- `정기적인 인덱스 리빌드가 필요`
    - 일반적인 인덱스보다도 크기에 민감하게 성능이 반응한다.
    - 이로 인해, 커버링 인덱스의 정기적인 크기 모니터링과 리빌드를 운용에 포함시켜야 한다.
- `SQL 구문에 새로운 필드가 추가되다면 사용할 수 없다.`
    - 인덱스 온리 스캔은 일반적인 인덱스에 비해 애플리케이션 유지 보수에 약한 타입의 튜닝이다.
