## 01강 DBMS 아키텍처 개요

> 각 언어마다 다르다. 하지만 **RDB로써 기능을 제공한다는 목적은 모두 동일**하다.
> 
> 
> ⇒ **모든 관계 모델이라는 수학적인 이론을 바탕**으로 한다. 즉, **기본적인 구조 자체는 모두 같다.**
> 

### DBMS 일반적인 아키텍처 개요

1. `쿼리 평가 엔진`
    - **사용자로부터 입력받은  SQL 구문 분석**
    - **어떤 순서로 기억장치의 데이터에 접근할지를 결정**
        - 이때 결정되는 계획을 `실행 계획`이라고 한다.
        - 실행 계획에 기반을 둬서 데이터에 접근하는 방법을 `접근 메서드`라고 한다.
    
    > 즉, **계획을 세우고 실행하는 DBMS의 핵심 기능을 담당하는 모듈**로 **성능과도 깊은 관련**이 있다.
    > 
2. `버퍼 매니저`
    - **DBMS는 버퍼라는 특병한 용도로 사용하는 메모리 영역을 확보해두는데 이 메모리 영역을 관리**
    - **디스크 용량 매니저와 함께 연동되어 작동** - 성능과 중요한 관련이 있다.
3. `디스크 용량 매니저`
    - **어디에 어떻게 데이터를 저장할지를 관리**
    - **데이터의 읽고 쓰기를 제어**
4. `트랜잭션 매니저와 락 매니저`
    - 데이터베이스에는 여러 사람이 접근하는데 각각의 처리는 DBMS 내부에서 트랜잭션 단위로 관리된다.
    - 이러한 **트랜잭션의 정합성을 유지하면서 실행시키고, 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시킴**
5. `리커버리 매니저`
    - **데이터를 정기적으로 백업하고, 문제가 일어났을 때 복구 담당**

<br>
<br>
<br>

---

<br>
<br>

## 02강 DBMS와 버퍼

> DBMS의 버퍼 매니저가 어떤 기능을 수행하는지 알아보자
> 

### [1] 공짜 밥은 존재할까?

**NO**. 많은 데이터를 영속적으로 저장하려면 속도를 잃고, 속도를 얻고자 한다면 많은 데이터를 영속적으로 저장하기 힘들다는 `트레이드오프`가 발생한다.

<br>

### [2] DBMS와 기억장치의 관계

디스크의 접근을 줄일 수 있다면 큰 폭의 성능 향상이 가능하다. 이는 일반적인 SQL 구문의 실행 시간 대부분을 저장소 I/O(입출력)에 사용하기 때문이다.

- `버퍼` 또는 `캐시`: 성능 향상을 목적으로 데이터를 저장하는 메모리
- 주로 메모리에 데이터를 두어 하드 디스크에 있는 데이터에 접근하는 것보다 훨씬 빠르다.

이런 고속 접근이 가능한 버퍼에 ‘**데이터를 어떻게, 어느 정도의 기간 동안 올릴지**’를 관리하는 것이 DBMS의 `버퍼 매니저`이다. ⇒ **성능에 중요한 영향을 끼침**

<br>

### [3] 메모리 위에 있는 두 개의 버퍼

- 데이터 캐시
- 로그 버퍼

대부분의 DBMS는 이러한 두 개의 역할을 하는 메모리 영역을 가지고 있다. 이러한 버퍼는 사용자가 용도에 따라 크기를 변경하는 것이 가능하다.

[1] `데이터 캐시`

  > **디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역**
  > 
  - 실행한 SELECT 구문에 데이터가 운 좋게 모두 이러한 데이터 캐시에 있다면, 디스크롸 같은 저장소에 접근하지 않고 처리가 수행되어 굉장히 빠르게 응답한다.
  - 하지만, 원하는 데이터가 없다면 디스크에 데이터를 찾으러 가야한다.

[2] `로그 버퍼`

  > **갱신 처리 (INSET, DELETE, UPDATE, MERGE)와 관련이 있다.**
  > 
  
  - **DBMS는 갱신과 관련된 SQL 구문을 사용자로부터 받으면 곧바로 저장소에 있는 데이터를 변경하지 않는다.**
  - **일단 로그 버퍼 위에 변경 정보를 보내고 이후 디스크에 변경을 수행한다.**
  - 이처럼 **데이터베이스의 갱신 처리는 SQL 구문의 실행 시점과 저장소에 갱신하는 시첨에 차이가 있는** `비동기 처리`이다.
      - 이는 **사실 성능을 높이기 위해서**이다. 조회 뿐만 아니라 갱신 작업도 시간이 걸리는 작업이기 때문에 사용자가 작업이 끝날 때까지 기다리게 되면 사용자는 오래 대기하게 된다.
      - 그래서 **일단 사용자에게는 작업이 끝났다고 통지하고 내부적으로는 관련된 처리를 계속 수행**한다.
  
💡 **저장소의 속도가 빨랐다면 이런 귀찮은 구조를 사용하지 않았어도 되었을 것이다.**

<br>

### [4] 메모리의 성질이 초래하는 트레이드오프

- `휘발성`: 하드위어 전원을 꺼버리면 메모리 위에 올라가 있는 모든 데이터가 사라진다.
- 휘발성의 문제점
    - 장애가 발생했을 때 **메모리에 있던 데이터가 모두 사라져버려** `데이터의 부정합`을 발생시키는 것이다.
    - `비동기로 동작`하는 **로그 버퍼 위에 존재하는 데이터가 디스크 위의 로그 파일에 반영되기 전에 장애가 발생해서 사라져 버린다면?**
        - 사용자가 수행했던 갱신 정보가 완전히 사라진다. (비니지스 관점에서 굉장히 심각한 문제)
    - 이를 회피하기 위해 DBMS는 **커밋 시점에 반드시 갱신 정보를 로그 파일에 씀으로써, 장애가 발생해도 정합성을 유지할 수 있게 한다.** → `커밋`
        - 커밋 때는 반드시 디스크에 `동기 접근`이 일어난다. 결국 여기서 지연이 발생할 수 있다. 즉, 트레이오프이다.

<br>

### [5] 시스템 특성에 따른 트레이드오프

- 데이터 캐시와 로그 버퍼의 크기
    - 대부분의 DBMS의 데이터 캐시와 로그 버퍼의 크기를 비교해보면 **데이터 캐시에 비해 로그 버퍼의 초깃값이 굉장히 작다.**
    - [ 이유 ] **검색 처리**를 할 때는 검색 대상 레코드가 **수백만에서 수천만 건**에 달하는 경우가 많다. 하지만 **갱신 처리**를 할 때는 생신 대상이 많아 봤자 트랜잭션마다 한 것에서 **수만 건 정도**밖에 안된다. (트랜잭션 규모에 따라 다를 수 있다)
    - 이는 **갱신 처리에 값 비싼 메모리를 많이 사용하는 것보다는, 자주 검색하는 데이터를 캐시에 올려놓는 것이 좋다고 생각하는 것**입니다.
    - 다만, **검색에 비해 갱신이 많다면** **초기 설정을 그대로 사용하지 말고 로그 버퍼의 크기를 늘려주는 튜닝(최적화)이 당연히 필요**하다.
- 검색과 갱신 중에서 중요한 것
    - 최근 DBMS는 꽤 발전해서, **리소스를 자동으로 조정하는 기능**도 가지고 있다. 하지만, 굉장히 중요한 리소스 배분이 필요한 상황에서 아무 생각 없이 모든 것을 자동 설정에 의지하는 것은 매우 위험하다.
    - **로그 버퍼가 크게 잡혀 있다. → 갱신 처리와 관련되어 큰 부하가 걸린다.**
    - **데이터 캐시가 크게 잡혀 있다. → 검색 처리와 관련된 처리가 중심이다.**

<br>

### [6] 추가적인 메모리 영역 ‘워킹 메모리’

2개의 버퍼 이외에도 일반적인 메모리 영역을 하나 더 가지고 있다.

- `워킹 메모리`: 정렬 또는 해시 관련 처리에 사용되는 작업용 영역
    - `정렬`: ORDER BY 구, 집합 연산, 윈도우 함수 기능을 사용할 때 실행
    - `해시`: 테이블 등의 결합에서 해시 결합이 사용되는 때 실행
    - 각 DBMS에 따라 이름과 관리 방법이 다르다.
    - 일반적으로 데이터 캐시와 로그 버퍼와 다른 영역으로 관리되는 경우가 많다.
        - 이 영역이 성능적으로 중요한 이유는 **만약 이 영역을 다루려는 데이터양보다 작아 부족해지는 경우가 생기면 대부분의 DBMS가 저장소를 사용하기 때문**이다.
        - **저장소에 접근하므로 속도가 느리다.**
- 저장소가 부족해지면 무슨 일이 일어날까?
    - 하나의 SQL 구문을 실행하고 있을 때는 메모리에 잘 들어가지만 여러 개의 SQL 구문을 동시에 실행하면 메모리가 넘치는 경우가 있다. 이러한 상황을 재현하는 검사를 실시하지 않으면 메모리 부족 현상이 일어날지 판별하기 힘들다.
    - **메모리가 부족하다는 이유로 SQL 구문에 오류를 절대 발생시키지 않습니다. 비록 느려지는 상황이 발생하더라도 상관없으니 어떻게든 끝까지 처리하려 노력합니다.**
    - 이는 DBMS가 중요한 데이터를 보관하고 처리할 때, **운영체제 정도의 급으로 처리 계속성을 담보하려 하기 때문**이다.

<br>
<br>
<br>

---

<br>
<br>

## 03강 DBMS와 실행 계획

사용자나 개발자가 데이터베이스에 의식적으로 사용하는 것은 SQL 레벨까지이다. 이후의 모든 것은 SQL 구문을 읽어들인 DBMS가 알아서 처리하고 결과를 제공해준다. 즉, 사용자는 데이터가 있는 곳을 알 필요가 없고 데이터에 접근하는 방법도 따로 생각하지 않는다.

### [1] 권한 이양의 죄악

- C, 자바와 같은 절차가 기초가 되는 언어는 사용자가 데이터에 접근하기 위한 절차(How)를 책임지고 기술하는 것이 전제이다.
- 반면, **비절차적인 RDB는 모든 일을 사용자가 아닌 시스템에게 맡겼다.**
    - 즉, **사용자가 하는 일은 대상(What)을 기술하는 것으로 축소**되었다.
    - 이렇게 한 이유가 존재한다. → ‘그렇게 하는 것이 비즈니스 전체의 생산성을 향상시키기 때문’이다.
    - 사실 이는 **절반은 맞고 절반은 틀리다**.
        - **우리가 RDB를 다루기 어려워한다.**
        - **HOW를 의식하지 않고 사용하는 것 때문에 성능 문제로 고생하는 경우도 꽤 있다.**
    
    💡 **RDB가 숨기고 있는 내부 절차를 들여다봐야 하는 것은 이러한 이유 때문이다.**  

<br>

### [2] 데이터에 접근하는 방법은 어떻게 결정할까?

- `쿼리 평가 엔진`: RDB에서 데이터 접근 절차를 결정하는 모듈
    - 사용자로부터 입력받은 SQL 구문(쿼리)을 처음 읽어들이는 모듈이기도 한다.
    - 파서 또는 옵티마이저와 같은 여러 개의 서브 모듈로 구성

- `파서`
    
    > 구문 분석
    > 
    - **SQL 구문이 구문적으로 올바른지 검사**
    - **SQL 구문을 정형적인 형식으로 변환**
        - DBMS 내부에서 일어나는 **후속 처리가 효율화된다.**
- `옵티마이저`
    - 최적화 대상은 데이터 접근법 (실행 계획)이다.
        - 옵티마이저는 바로 `DBMS 두뇌의 핵심`
    - 순서
        1. **인덱스 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등의 조건을 고려해서, 선택 가능한 많은 실행 계획을 작성**
        2. **이들의 비용을 연산해**
        3. **가장 낮은 비용을 가진 실행 계획을 선택**
    
    > 이 작업들은 굉장히 귀찮은 일로 **RDB가 데이터 접근의 절차 지향 결정을 자동화해 기계적으로 처리해준다.**
    > 
- `카탈로그 매니저`
    - **옵티마이저가 실행 계획을 세울 때 옵티마이저에게 중요한 정보를 제공**
    - `카탈로그`: **DBMS의 내부 정보를 모아놓은 테이블들**로, 테이블 또는 인덱스의 통계 정보가 저장되어 있다.
- `플랜 평가`
    - 옵티마이저가 SQL 구문에서 여러 개의 실행 계획을 세운 뒤 그것을 받아 최적의 실행 결과를 선택하는 것
    - **실행 계획이라는 것**은 곧바로 DBMS가 실행할 수 있는 형태의 코드가 아니라 **문자 그대로의 계획서**이다.
        - 따라서 성능이 좋지 않은 SQL 구문이 있을 때 **실행 계획을 읽고, 수정 방안 고려 가능**

<br>

### [3] 옵티마이저와 통계 정보

- **옵티마이저가 명령하는 대로 다 잘 처리해주는 만능은 아니다.**
- 특히, 카탈로그 매니저가 관리하는 통계 정보에 대해서는 데이터베이스 엔지니어가 항상 신경을 써줘야 한다.
- **플랜 선택을 옵티마이저에게 맡기는 경우, 실제로 최적의 플랜이 선택되지 않는 경우가 꽤 많다.**
    - **통계 정보가 부족한 경우가 대표적인 원인으로 꼽힌다.**
    - 카탈로그에 포함되어 있는 통계 정보 (구현에 따라 다름)
        - 각 테이블의 레코드 수
        - 각 테이블의 필드 수와 필드의 크기
        - 필드의 카디널리티 (값의 개수)
        - 필드값의 히스토그램 (어떤 값이 얼마나 분포되어 있는가)
        - 필드 내부에 있는 NULL 수
        - 인덱스 정보
    - 옵티마이저는 이런 카탈로그를 활용해 실행 계획을 만들기 때문에 **이런 카탈로그 정보가 테이블 또는 인덱스의 실제와 일치하지 않을 때 문제가 생긴다.**
        - **테이블에 데이터 삽입/갱신/제거가 수행될 때 카탈로그 정보가 갱신되지 않을 때**
        - 과거 정보를 가지고 있기 때문에 잘못된 계획을 세울 수 밖에 없다.

<br>

### [4] 최적의 실행 계획이 작성되면

💡 **올바른 통계 정보가 모이는 것은 SQL 성능에 있어서 굉장히 중요한 문제**

⇒ **테이블의 데이터가 많이 바뀌면 카탈로그의 통계 정보도 함께 갱신해야 한다.**

- 수동 처리 / 배치 처리 / 자동 처리

통계 갱신은 대상 테이블 또는 인덱스의 크기와 수에 따라 몇십 분에서 몇 시간이 소요되기도 하는 실행 비용이 굉장히 높은 작업이다. 하지만 DBMS가 최적의 플랜을 선택하려면 필요한 조건이므로 갱신 시점을 확실하게 검토해야 한다.

<br>
<br>
<br>

---

<br>
<br>

## 04강 실행 계획이 SQL 구문의 성능을 결정

### [1] 실행 계획 확인 방법

- SQL 구문의 지연이 발생했을 때 제일 먼저 실행 계획을 살펴봐야 한다.
- 각 DBMS마다 실행 계획을 확인하는 명령어를 제공한다.

| 이름 | 명령어 |
| --- | --- |
| Oracle | set autotrace traceonly |
| Microsoft SQL Server | SET SHOWPLAN_TEXT ON |
| PostgreSQL | EXPLAIN SQL 구문 |
| MySQL | EXPLAIN EXTENDED SQL 구문 |

<br>

### [2] 테이블 풀 스캔의 실행 계획

> 레코드 전체를 검색할 때
> 

```sql
SELECT * FROM Shops;
```

- 실행 계획을 출력해보면 공통적으로 나타나는 것이 있다.
    1. **조작 대상 객체**
        
        > 테이블 이름 - shops
        > 
    2. **객체에 대한 조작의 종류**
        
        > DBMS마다 이름이 다르다. - Seq Scan(PostgreSQL), Table Access Full(Oracle)
        > 
    3. **조작 대상이 되는 레코드 수**
        
        > 테이블 데이터 수
        > 
        > - **통계 정보를 믿고 실제 테이블을 보지 않는다.**
- 실행 계획의 실행 비용과 실행 시간
    - 추정되는 실행 시간으로, 절대 지표로 사용할 수 없다.
    - 각 DBMA에 맞게 실제 실행 시간을 출력해봐야 한다.

<br>

### [3] 인덱스 스캔의 실행 계획

```sql
SELECT * FROM Shops WHERE shop_id='00050';
```

- 이전과 마찬가지로 3개의 부분으로 나누어 살펴보자.
    1. 조작 대상이 되는 레코드 수
        
        > 1개 - 조건이 있으므로 접근 대상이 반드시 하나이기 때문이다.
        > 
    2. 접근 대상 객체와 조작
        
        > Index Scan(PostgreSQL), INDEX UNIQUE SCAN(Oracle)
        > 
        > - 인덱스는 스캔하는 모집합 레코드 수에서 선택되는 레코드 수가 적다면 테이블 풀 스캔보다 빠르게 접근을 수행

<br>

### [4] 간단한 테이블 결합의 실행 계획

- SQL에서 지연이 일어나는 경우는 대부분 결합과 관련된 것
- 실행 계획이 상당히 복잡해지므로, 옵티마이저도 최적의 실행 계획을 세우기 어렵다.

> 결합의 실행 계획을 이해하는 것이 이 책의 목적 중의 하나
> 

```sql
SELECT shop_name
FROM Shops S INNER JOIN Reservation R
ON S.shop_id=R.shop_id;
```

- DBMS는 결합을 할 때 세가지 종류의 알고리즘을 사용
    1. `Nested Loops`: 가장 간단 결합 알고리즘으로 한쪽 테이블을 읽으면서 코드 하나마다 결합 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식
    2. `Sort Merge`: 결합 키(현재 예제에서는 점포 ID)로 레코드를 정렬하고, 순차적으로 두 개의 테이블을 결합하는 방식 
        - 결합 전 정렬을 수행해야 하는데 작업용 메모리로 워킹 메모리를 사용
    3. `Hash`: 결합 키 값을 해시 값으로 맵핑하는 방법
        - 해시 테이블을 만들어야 하므로, 마찬가지로 작업용 메모리 영역이 필요
- 객체에 대한 조작의 종류
    
    > NESTED LOOPS(PostgreSQL), NESTED LOOPS(Oracle)
    > 

<br>
<br>
<br>

---

<br>
<br>

## 05강 실행 계획의 중요성

💡 **옵티마이저는 우수하지만 완벽하지는 않다.**

- 만약, 옵티마이저가 선택하는 실행 계획이 최적의 방법이 아니라면
- 힌트 구를 사용해 옵티마이저에게 강제적으로 명령


**실행 계획을 변경하려면 어떤 선택지가 있는지 알아야 한다.** 하지만 이 전에 SQL 구문과 SQL 구문들이 어떠한 접근 경로로 데이터를 검색하는지, 어떤 테이블 설정이 효율적인지, 또는 실행 계획을 예측할 수 있어야 한다. 

- **이런 것들이 물리 계층을 은폐한다는 RDB의 목표를 거스르는 일이지만, 이상에 도달하지 못한 현실에 살고 있는 우리에게는 이상적이지 않는 방법도 필요하다.**
