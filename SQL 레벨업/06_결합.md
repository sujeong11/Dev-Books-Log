## 18강 기능적 관점으로 구분하는 결합의 종류

- `크로스 결합`
- `내부 결합`
- `외부 결합`
- `자기 결합`
- `등가 결합 / 비등가 결합`
- `자연 결합` (특별한 이유가 없다면, 그냥 내부 결합 사용 추천)

<br>

### [1] 크로스 결합 - 모든 결합의 모체

> 결과: 테이블 개수 * 테이블 개수
> 
- 실무에서 사용할 일이 거의 없다.
    - 이런 결과가 필요한 경우가 없다.
    - 비용이 많이 드는 연산이다.
- 실수로 사용하는 경우
    - 결합 조건이 없으므로 모든 조합을 만들어버린다.
    
    ```sql
    SELECT * FROM Employees, Departments;
    ```
    
💡 크로스 결합이 다른 모든 결합 연산의 모체이다.

<br>

### [2] 내부 결합 - 왜 ‘내부’라는 말을 사용할까?

```sql
SELECT E.emp_id, E.empname, E.dept_id, D.dept_name
FROM Employees E
INNER JOIN Departments D ON E.dept_id = D.dept_id;
```

- **내부 결합의 결과**를 모두 `크로스 결합의 일부`라는 것을 알 수 있다.
- 내부 결합과 같은 기능을 하는 `상관 서브쿼리`
    
    ```sql
    SELECT E.emp_id, E.empname, E.dept_id,
          (SELECT D.dept_name
           FROM Department D
           WHERE E.dept_id = D.dept_id) AS dept_name
    FROM Employees E;
    ```
    
    - 단, 상관 서브쿼리를 `스칼라 서브쿼리`(리턴 값이 하나의 단일 값인 쿼리)로 사용하면 결과 레코드 수만큼 상관 서브쿼리를 시행해 비용이 꽤 높아진다.
    - **결합을 우선적으로 사용하자.**

<br>

### [3] 외부 결합 - 왜 ‘외부’라는 말을 사용할까?

1. 왼쪽 외부 결합
2. 오른쪽 외부 결합
3. 완전 외부 결합

```sql
SELECT E.emp_id, E.empname, E.dept_id, D.dept_name
FROM Departments D
LEFT OUTER JOIN Employees E ON D.dept_id = E.dept_id;
```

- **마스터 테이블 쪽에만 존재하는 키가 있을 때는 해당 키를 제거하지 않고 결과에 보존**

<br>

### [4] 외부 결합과 내부 결합의 차이

- 크로스 결합, 내부 결합 - `NULL 생성하지 않음`
- 외부 결합 - `NULL 생성`

<br>

### [5] 자기 결합 - ‘자기’란 누구일까?

> 같은 테이블을 사용해 결합하는 것
> 
- 가능한 조합
    - `자기 결합 + 크로스 결합`
    
    ```sql
    SELECT D1.digit + (D2.digit * 10) AS seq
    FROM Digits D1 CROSS JOIN Digits D2; // 레코드 수: 10 * 10
    ```
    
    - `자기 결합 + 외부 결합`
- 자기 결합의 사고방식
    - **같은 테이블에 별칭을 붙여 마치 다른 테이블인 것처럼 다룬다.**

<br>
<br>
<br>

---

<br>
<br>

## 19강 결합 알고리즘과 성능

- 옵티마이저가 선택 가능한 결합 알고리즘 (`각 DBMS마다 다름`)
    
    > 데이터 크기 또는 결합 키의 분산이라는 요인에 따라 달라진다.
    > 
    - `Nested Loops` (기본)
    - `Hash`
    - `Sort Merge`

<br>

### [1] Nested Loops

> 중첩 반복을 사용하는 알고리즘 (모든 DBMS에서 지원)
> 
- Table_A(`구동/외부 테이블`), Table_B(`내부 테이블`)
- 접근하게 되는 레코드 수는 `Table_A * Table_B` → 실행 시간은 레코드 수에 비례
- 한 번의 단계에서 처리하는 레코드 수가 적으므로 Hash / Sort merge에 비해 메모리 소비가 적다.
- **구동 테이블의 중요성 (**`Nested Loops의 성능을 개선하는 키워드`**)**
    - **구동 테이블로는 작은 테이블을 선택하는 것**
    - 만약, **내부 테이블에 결합 키 필드에 인덱스가 존재**한다면, **해당 인덱스를 통해 DBMS는 내부 테이블을 완전히 순회하지 않아도 된다.** (내부 테이블 반복을 어느 정도 건너뛸 수 있음)
    - 즉, **내부 테이블이 더 클수록 인덱스 사용으로 인한 반복 생략 효과가 커진다.**
- 단점
    - **결합 키가 내부 테이블에 유일하지 않은 경우** 성능이 안 나올 수 있다.
        - 인덱스를 사용해 반복을 생략할 수 있다고 해도, 데이터의 양이 너무 많으면 반복이 많이 일어나기 때문이다.
- 해결 방법
    - [1] **구동 테이블로 큰 테이블을 선택하는 역설적인 방법**
        - **내부 테이블에 대한 점포 테이블의 접근이 기본 키로 수행**되므로 **항상 하나의 레코드로 접근하는 것이 보장**된다.
    - [2] **해시**

<br>

### [2] Hash

> 입력에 대해 어느 정도 유일성과 균일성을 가진 값을 출력하는 함수
> 
- 해시 결합
    1. **작은 테이블을 스캔해 결합 키에 해시 함수를 적용해서 해시값으로 변환**한다.
    2. **다른 큰 테이블을 스캔**하고, **결합 키가 해시 값에 존재하는지를 확인하는 방법으로 결합으로 수행**한다.
- `작은 테이블에서 해시 테이블을 만드는 이유`
    - **해시 테이블은 DBMS의 워킹 메모리에 저장**되므로 **조금이라도 작은 것이 효율적**이기 때문이다.
- 특징
    - Nested Loops에 비해 **메모리를 크게 소모 (해시테이블 생성하므로)** → 동시 실행성이 높은 작업에는 부적절
    - 메모리가 부족하면 저장소를 사용하므로 지연이 발생
    - 출력되는 해시 값은 입력 값의 순서를 알지 못하므로 **등치 결합에만 사용 가능**
- 유용한 경우
    - Nested Loops에서 **적절한 구동 테이블 (상대적으로 충분히 작은 테이블)이 존재하지 않는 경우**
    - “” 존재하지만 **내부 테이블에서 히트되는 레코드 수가 너무 많은 경우**
    - Nested Loops의 **내부 테이블에 인덱스가 존재하지 않는 경우**

💡 Nested Loops가 효율적으로 작동하지 않는 경우의 차선책이 Hash

Hash 결합은 반드시 양쪽 테이블의 레코드를 전부 읽어야 하므로, 테이블 풀 스캔이 사용되는 경우가 많다. → **테이블 규모가 굉장히 크다면 조심해야 한다.**

<br>

### [3] Sort Merge

- 결합 대상 테이블들을 각각 결합 키로 정렬하고, 일치하는 결합 키를 찾으면 결합한다.
- 특징
    - 정렬하므로 많은 메모리 소비
    - 메모리 부족으로 I/O 비용이 늘어나고 지연이 발생할 위험 존재
    - 동치 결합만 아닌 부등호를 사용한 결합 사용 가능 (단, 부정 조건 불가능)
    - 테이블 정렬하므로 한 쪽 테이블을 모두 스캔한 시점에 결합을 완료할 수 있다.
- 유효한 경우
    - 테이블 정렬을 생략할 수 있는 예외적인 상황
    
    💡 **이 외의 경우 Nested Loop와 Hash를 우선적으로 고려하자.**

<br>

### [4] 의도하지 않은 크로스 결합

- 의도하지 않게 크로스 결합이 나타나는 경우가 있다. - `삼각 결합`
    
    ```sql
    SELECT A.col_a, B.col_b, C.col_c
    FROM Table_A A
      INNER JOIN Table_B B
        ON A.col_a = B.col_b
      INNER JOIN Table_C C
        ON A.col_a = C.col_c
    ```
    
    - 실행 계획
    - A + B + C / A + C + B / B + A + C / C + A + B 네 가지
- Nested Loops가 선택되는 경우
    
    > 별로 문제될 것이 없다.
    > 
- 크로스 결합이 선택되는 경우
    - (B + C + A 경우, B와 C 사이에는 결합 조건이 없어 크로스 결합이 실행된다.)
    - B, C의 크기가 작다고 평가했을 때 해당 실행 계획을 선택될 수 있다. 단, B와 C의 크기가 작을 때는 클로스 결합을 두려워할 필요가 없다.
- 의도하지 않은 클로스 결합을 회피하는 방법
    - 결합 조건이 존재하지 않는 테이블 사이에 불필요한 결합 조건을 추가
    
    ```sql
    SELECT A.col_a, B.col_b, C.col_c
    FROM Table_A A
      INNER JOIN Table_B B
        ON A.col_a = B.col_b
      INNER JOIN Table_C C
        ON A.col_a = C.col_c
        AND C.col_c = B.col_b; 
    ```
    

<br>
<br>
<br>

---

<br>
<br>

## 20강 결합이 느리다면

### [1] 상황에 따른 최적의 결합 알고리즘

- 소규모 - 소규모
    - **어떤 알고리즘**이든 성능 차이가 크지 않다.
- 소규모 - 대규모
    - `Nested Loops` → **대규모 테이블의 결합 키에 인덱스를 만들어주는 것**을 잊지 말자.
    - 내부 테이블의 결합 대상 레코드가 너무 많다면 **구동 테이블과 내부 테이블을 바꾸거나**, **Hash 사용**을 검토하라.
- 대규모 - 대규모
    - 일단 **Hash 사용**
    - 결합 키로 **처음부터 정렬**되어 있다면 **Sort Merge를 사용**

<br>

### [2] 실행 계획 제어

- 사용자가 제어 가능할 수도 있고 불가능할 수도 있다. (제어한다면 성능 테스트 필요)
- 방법은 DBMS마다 다르다.

<br>

### [3] 흔들리는 실행 계획

- 옵티마이저에게 맡겨도 역시 최적의 실행 계획이 선택되지 않는 경우가 있다.
- 실행 계획 변동이 일어나기 가장 쉬운 연산이 결합이다. (결합은 여러 알고리즘을 선택 가능하므로)
- 따라서 SQL 성능의 변동 위험을 줄이려면 되도록 결합을 피해야 한다. (결합을 회피하는 대체 수단은 후반부에 다룸)
